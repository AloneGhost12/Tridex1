<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Panel</title>
    <link rel="stylesheet" href="style.css">
    <!-- Include the ban system script -->
    <script src="ban-system.js"></script>
    <style>
        table { border-collapse: collapse; width: 100%; margin-top: 24px; }
        th, td { border: 1px solid #ccc; padding: 8px 12px; text-align: left; }
        th { background: #f8f8f8; }
        .ban-btn, .unban-btn, .delete-btn {
            padding: 5px 14px;
            border: none;
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            margin-right: 6px;
        }
        .ban-btn { background: #dc3545; }
        .unban-btn { background: #28a745; }
        .delete-btn { background: #888; }
        /* Modal styles */
        #user-detail-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.3);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }
        #user-detail-modal > div {
            background: #fff;
            padding: 32px 24px;
            border-radius: 8px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.15);
            min-width: 300px;
            max-width: 90vw;
        }
        /* Product admin styles */
        #product-form input, #product-form textarea { margin-bottom: 8px; display: block; width: 100%; }
        #product-list img { max-width: 60px; max-height: 60px; }
        .edit-btn { background: #007bff; color: #fff; border: none; border-radius: 4px; padding: 5px 14px; cursor: pointer; margin-right: 6px; }
        .admin-nav-btn {
            padding: 8px 18px;
            margin-right: 10px;
            background: #007bff;
            color: #fff;
            border: none;
            border-radius: 5px;
            font-size: 1rem;
            cursor: pointer;
        }
        .admin-nav-btn.active {
            background: #0056b3;
        }
        @keyframes spin {
            0% { transform: rotate(0deg);}
            100% { transform: rotate(360deg);}
        }
    </style>
</head>
<body>
    <!-- Loading animation overlay -->
    <div id="loading-overlay" style="display:flex; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(255,255,255,0.7); z-index:99999; align-items:center; justify-content:center;">
        <div style="border:6px solid #f3f3f3; border-top:6px solid #007bff; border-radius:50%; width:48px; height:48px; animation:spin 1s linear infinite;"></div>
    </div>
    <h1>Admin Panel</h1>
    <!-- Admin controls -->
    <div class="admin-controls" style="margin-bottom:15px;">
        <button id="verify-cloudinary-btn" class="btn btn-info btn-sm" style="padding:5px 10px; background:#17a2b8; color:white; border:none; border-radius:4px; cursor:pointer; margin-right:10px;">Check Cloudinary Connection</button>
        <button id="verify-product-images-btn" class="btn btn-info btn-sm" style="padding:5px 10px; background:#6c757d; color:white; border:none; border-radius:4px; cursor:pointer;">Verify Product Images</button>
        <span id="cloudinary-status" style="margin-left:10px; font-size:0.9em;"></span>
    </div>

    <!-- Admin navigation buttons -->
    <div style="margin-bottom:24px;">
        <button class="admin-nav-btn active" id="show-users-btn">User Details</button>
        <button class="admin-nav-btn" id="show-products-btn">Product Management</button>
        <button class="admin-nav-btn" id="show-mail-btn" title="Send Announcement">&#9993; Mail</button>
    </div>

    <!-- User Details Section -->
    <div id="user-section">
        <div style="margin-bottom: 15px;">
            <button id="debug-ban-system" style="padding: 8px 15px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">Debug Ban System</button>
            <span id="debug-output" style="margin-left: 10px; font-family: monospace;"></span>
        </div>
        <table id="user-table">
            <thead>
                <tr>
                    <th>Username</th>
                    <th>Email</th>
                    <th>Phone</th>
                    <th>Age</th>
                    <th>Password</th>
                    <th>Status</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody>
                <!-- User rows will be rendered here -->
            </tbody>
        </table>
        <!-- User detail modal -->
        <div id="user-detail-modal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.3); z-index:2000; align-items:center; justify-content:center;">
            <div style="background:#fff; padding:32px 24px; border-radius:8px; box-shadow:0 2px 12px rgba(0,0,0,0.15); min-width:300px; max-width:90vw;">
                <h2>User Details</h2>
                <div id="user-detail-content"></div>
                <button id="close-user-detail" style="margin-top:18px; padding:8px 18px; background:#007bff; color:#fff; border:none; border-radius:5px; font-size:1rem; cursor:pointer;">Close</button>
            </div>
        </div>
    </div>

    <!-- Product Management Section -->
    <div id="product-section" style="display:none;">
        <form id="product-form">
            <input type="hidden" id="product-id">
            <label>Product Name: <input type="text" id="product-name" required></label>
            <!-- Image upload and preview -->
            <label>Image: <input type="file" id="product-image-file" accept="image/*"></label>
            <input type="hidden" id="product-image">
            <img id="product-image-preview" src="" alt="Preview" style="display:none;max-width:80px;max-height:80px;margin-bottom:8px;">
            <label>Description: <textarea id="product-desc" required></textarea></label>
            <label>Price: <input type="number" id="product-price" min="1" required></label>
            <button type="submit" id="product-save-btn">Add Product</button>
            <button type="button" id="product-cancel-btn" style="display:none;">Cancel</button>
        </form>
        <table id="product-list">
            <thead>
                <tr>
                    <th>Photo</th>
                    <th>Name</th>
                    <th>Description</th>
                    <th>Price</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody>
                <!-- Product rows will be rendered here -->
            </tbody>
        </table>
    </div>

    <!-- Mailbox Modal for Admin -->
    <div id="admin-mail-modal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.3); z-index:3000; align-items:center; justify-content:center;">
        <div style="background:#fff; padding:32px 24px; border-radius:8px; box-shadow:0 2px 12px rgba(0,0,0,0.15); min-width:320px; max-width:90vw;">
            <h2 style="margin-top:0;">Send Announcement</h2>
            <form id="admin-mail-form">
                <label>Title: <input type="text" id="mail-title" required></label><br>
                <label>Message:<br>
                    <textarea id="mail-body" required style="width:100%;height:80px;"></textarea>
                </label><br>
                <button type="submit" style="padding:8px 18px; background:#007bff; color:#fff; border:none; border-radius:5px; font-size:1rem; cursor:pointer;">Send</button>
                <button type="button" id="close-admin-mail" style="padding:8px 18px; background:#888; color:#fff; border:none; border-radius:5px; font-size:1rem; cursor:pointer; margin-left:10px;">Cancel</button>
            </form>
            <hr style="margin:18px 0;">
            <h3>All Announcements</h3>
            <div id="admin-mailbox-messages" style="max-height:300px; overflow-y:auto; margin-bottom:10px;"></div>
        </div>
    </div>

    <script>
        // --- Simple login protection: redirect to login.html if not logged in ---
        if (!localStorage.getItem('token')) {
            window.location.href = 'login.html';
        }
        // Enforce admin-only access
        if (localStorage.getItem('isAdmin') !== 'true') {
            window.location.href = 'index.html';
        }

        // Make sure isLoggedIn flag is set (needed for cart and mailbox access)
        if (localStorage.getItem('token') && !localStorage.getItem('isLoggedIn')) {
            localStorage.setItem('isLoggedIn', 'true');
        }

        // Make sure currentUser is set (needed for cart functionality)
        if (!localStorage.getItem('currentUser') && localStorage.getItem('username')) {
            localStorage.setItem('currentUser', localStorage.getItem('username'));
        }

        let users = [];
        let products = [];
        let announcements = [];

        // Load users from backend
        async function fetchUsers() {
            try {
                const res = await fetch('https://tridex1.onrender.com/users');
                users = await res.json();
                renderUsers();
            } catch (e) {
                users = [];
                renderUsers();
                alert('Failed to load users from database.');
            }
        }

        function renderUsers() {
            const tbody = document.querySelector('#user-table tbody');
            tbody.innerHTML = '';
            users.forEach(user => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td class="username-link" style="color:#007bff; cursor:pointer; text-decoration:underline;">
                        ${user.username || ''} ${user.verified ? '<span title="Verified" style="color:#1da1f2; font-size:1.1em;vertical-align:middle;">&#10004;&#65039;</span>' : ''}
                    </td>
                    <td>${user.email || ''}</td>
                    <td>${user.phone || ''}</td>
                    <td>${user.age || ''}</td>
                    <td>${user.password || ''}</td>
                    <td>${user.banned ? '<span style="color:red;">Banned</span>' : 'Active'}</td>
                    <td>
                        <button type="button" class="ban-btn"${user.banned ? ' style="display:none;"' : ''}>Ban</button>
                        <button type="button" class="unban-btn"${!user.banned ? ' style="display:none;"' : ''}>Unban</button>
                        <button type="button" class="delete-btn">Delete</button>
                        <button type="button" class="verify-btn"${user.verified ? ' style="display:none;"' : ''}>Verify</button>
                    </td>
                `;
                // Show user details on username click
                tr.querySelector('.username-link').onclick = function() {
                    showUserDetail(user);
                };
                // Ban user (update DB in real app)
                tr.querySelector('.ban-btn').onclick = async function() {
                    if (confirm(`Ban ${user.username}?`)) {
                        try {
                            // Show loading indicator
                            showLoading();

                            // Call the server to ban the user
                            const response = await fetch(`https://tridex1.onrender.com/users/${user._id}/ban`, { method: 'PUT' });

                            // Log server response
                            console.log(`Server ban response for ${user.username}:`, response.status);

                            // Also ban the user locally using our ban system
                            if (window.banSystem) {
                                const result = window.banSystem.banUser(user.username);
                                console.log(`User ${user.username} ban result: ${result ? 'success' : 'failed'}`);

                                // Update the debug output
                                const bannedUsers = window.banSystem.debugBanSystem();
                                document.getElementById('debug-output').textContent =
                                    bannedUsers.length > 0 ?
                                    `Banned users: ${bannedUsers.join(', ')}` :
                                    'No banned users found';
                            }

                            // Update the UI to show the user is now banned
                            const statusCell = tr.querySelector('td:nth-child(6)');
                            if (statusCell) {
                                statusCell.innerHTML = '<span style="color:red;">Banned</span>';
                            }

                            // Hide the ban button and show the unban button
                            tr.querySelector('.ban-btn').style.display = 'none';
                            tr.querySelector('.unban-btn').style.display = '';

                            // Refresh the user list
                            fetchUsers();
                        } catch (e) {
                            console.error('Failed to ban user on server:', e);

                            // If server fails, still ban locally
                            if (window.banSystem) {
                                const result = window.banSystem.banUser(user.username);
                                console.log(`User ${user.username} local ban result: ${result ? 'success' : 'failed'}`);

                                // Update the debug output
                                const bannedUsers = window.banSystem.debugBanSystem();
                                document.getElementById('debug-output').textContent =
                                    bannedUsers.length > 0 ?
                                    `Banned users: ${bannedUsers.join(', ')}` :
                                    'No banned users found';

                                // Update the UI to show the user is now banned
                                const statusCell = tr.querySelector('td:nth-child(6)');
                                if (statusCell) {
                                    statusCell.innerHTML = '<span style="color:red;">Banned</span>';
                                }

                                // Hide the ban button and show the unban button
                                tr.querySelector('.ban-btn').style.display = 'none';
                                tr.querySelector('.unban-btn').style.display = '';

                                // Refresh the user list
                                fetchUsers();
                            } else {
                                alert('Failed to ban user.');
                            }
                        } finally {
                            // Hide loading indicator
                            hideLoading();
                        }
                    }
                };
                // Unban user (update DB in real app)
                tr.querySelector('.unban-btn').onclick = async function() {
                    if (confirm(`Unban ${user.username}?`)) {
                        try {
                            // Show loading indicator
                            showLoading();

                            // Call the server to unban the user
                            const response = await fetch(`https://tridex1.onrender.com/users/${user._id}/unban`, { method: 'PUT' });

                            // Log server response
                            console.log(`Server unban response for ${user.username}:`, response.status);

                            // Also unban the user locally using our ban system
                            if (window.banSystem) {
                                const result = window.banSystem.unbanUser(user.username);
                                console.log(`User ${user.username} unban result: ${result ? 'success' : 'failed'}`);

                                // Update the debug output
                                const bannedUsers = window.banSystem.debugBanSystem();
                                document.getElementById('debug-output').textContent =
                                    bannedUsers.length > 0 ?
                                    `Banned users: ${bannedUsers.join(', ')}` :
                                    'No banned users found';
                            }

                            // Update the UI to show the user is now unbanned
                            const statusCell = tr.querySelector('td:nth-child(6)');
                            if (statusCell) {
                                statusCell.innerHTML = 'Active';
                            }

                            // Show the ban button and hide the unban button
                            tr.querySelector('.ban-btn').style.display = '';
                            tr.querySelector('.unban-btn').style.display = 'none';

                            // Refresh the user list
                            fetchUsers();
                        } catch (e) {
                            console.error('Failed to unban user on server:', e);

                            // If server fails, still unban locally
                            if (window.banSystem) {
                                const result = window.banSystem.unbanUser(user.username);
                                console.log(`User ${user.username} local unban result: ${result ? 'success' : 'failed'}`);

                                // Update the debug output
                                const bannedUsers = window.banSystem.debugBanSystem();
                                document.getElementById('debug-output').textContent =
                                    bannedUsers.length > 0 ?
                                    `Banned users: ${bannedUsers.join(', ')}` :
                                    'No banned users found';

                                // Update the UI to show the user is now unbanned
                                const statusCell = tr.querySelector('td:nth-child(6)');
                                if (statusCell) {
                                    statusCell.innerHTML = 'Active';
                                }

                                // Show the ban button and hide the unban button
                                tr.querySelector('.ban-btn').style.display = '';
                                tr.querySelector('.unban-btn').style.display = 'none';

                                // Refresh the user list
                                fetchUsers();
                            } else {
                                alert('Failed to unban user.');
                            }
                        } finally {
                            // Hide loading indicator
                            hideLoading();
                        }
                    }
                };
                // Delete user (update DB in real app)
                tr.querySelector('.delete-btn').onclick = async function() {
                    if (confirm(`Delete ${user.username}?`)) {
                        try {
                            await fetch(`https://tridex1.onrender.com/users/${user._id}`, { method: 'DELETE' });
                            fetchUsers();
                        } catch (e) { alert('Failed to delete user.'); }
                    }
                };
                // Verify user (update DB in real app)
                tr.querySelector('.verify-btn').onclick = async function() {
                    try {
                        await fetch(`https://tridex1.onrender.com/users/${user._id}/verify`, { method: 'PUT' });
                        fetchUsers();
                    } catch (e) { alert('Failed to verify user.'); }
                };
                tbody.appendChild(tr);
            });
        }

        function showUserDetail(user) {
            const modal = document.getElementById('user-detail-modal');
            const content = document.getElementById('user-detail-content');
            // Show all fields dynamically
            let html = '';
            for (const key in user) {
                if (user.hasOwnProperty(key)) {
                    html += `<p><strong>${key.charAt(0).toUpperCase() + key.slice(1)}:</strong> ${user[key]}</p>`;
                }
            }
            content.innerHTML = html;
            modal.style.display = 'flex';
        }

        document.getElementById('close-user-detail').onclick = function() {
            document.getElementById('user-detail-modal').style.display = 'none';
        };

        // --- Product Management (DB version) ---
        async function fetchProducts() {
            try {
                const res = await fetch('https://tridex1.onrender.com/products');
                products = await res.json();
                renderProducts();
            } catch (e) {
                products = [];
                renderProducts();
                alert('Failed to load products from database.');
            }
        }
        function renderProducts() {
            const tbody = document.querySelector('#product-list tbody');
            tbody.innerHTML = '';
            (products || []).forEach(product => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td><img src="${product.image || ''}" alt="${product.name}" style="cursor:pointer;" class="product-img" data-id="${product._id}"></td>
                    <td>${product.name}</td>
                    <td>${product.desc}</td>
                    <td>â‚¹${product.price}</td>
                    <td>
                        <button class="edit-btn" data-id="${product._id}">Edit</button>
                        <button class="delete-btn" data-id="${product._id}">Delete</button>
                    </td>
                `;
                tr.querySelector('.product-img').onclick = function() {
                    window.location.href = `product-details.html?id=${product._id}`;
                };
                tr.querySelector('.edit-btn').onclick = function() {
                    setProductForm(product);
                };
                tr.querySelector('.delete-btn').onclick = async function() {
                    if (confirm('Delete this product?')) {
                        try {
                            await fetch(`https://tridex1.onrender.com/products/${product._id}`, { method: 'DELETE' });
                            fetchProducts();
                        } catch (e) { alert('Failed to delete product.'); }
                    }
                };
                tbody.appendChild(tr);
            });
        }
        // Set form fields for editing, including image preview
        function setProductForm(product) {
            document.getElementById('product-id').value = product._id;
            document.getElementById('product-name').value = product.name;
            document.getElementById('product-image').value = product.image;
            document.getElementById('product-desc').value = product.desc;
            document.getElementById('product-price').value = product.price;
            document.getElementById('product-save-btn').textContent = 'Update Product';
            document.getElementById('product-cancel-btn').style.display = '';
            if (product.image) {
                document.getElementById('product-image-preview').src = product.image;
                document.getElementById('product-image-preview').style.display = '';
            } else {
                document.getElementById('product-image-preview').style.display = 'none';
            }
            document.getElementById('product-image-file').value = '';
        }
        // Handle image file upload and processing
        document.getElementById('product-image-file').addEventListener('change', async function(e) {
            const file = e.target.files[0];
            if (file) {
                // Check file size (limit to 10MB for Cloudinary's free tier)
                if (file.size > 10 * 1024 * 1024) {
                    alert('Image size exceeds 10MB, which is Cloudinary\'s limit. Please choose a smaller image.');
                    this.value = ''; // Clear the file input
                    return;
                }

                // Show loading indicator
                showLoading();

                // Show upload status message
                const statusDiv = document.createElement('div');
                statusDiv.id = 'upload-status';
                statusDiv.style.cssText = 'margin-top:10px; font-size:0.9em; color:#007bff;';
                statusDiv.textContent = 'Uploading to Cloudinary... Please wait.';

                const previewContainer = document.getElementById('product-image-preview').parentNode;
                if (document.getElementById('upload-status')) {
                    document.getElementById('upload-status').remove();
                }
                previewContainer.appendChild(statusDiv);

                try {
                    // Upload the image to Cloudinary
                    const imageUrl = await uploadToCloudinary(file);

                    // Update status
                    if (document.getElementById('upload-status')) {
                        document.getElementById('upload-status').textContent = 'Upload complete!';
                        document.getElementById('upload-status').style.color = '#28a745';
                    }

                    // Set the image URL to the hidden input
                    document.getElementById('product-image').value = imageUrl;

                    // Show preview
                    document.getElementById('product-image-preview').src = imageUrl;
                    document.getElementById('product-image-preview').style.display = '';

                    // Check if it's a Cloudinary URL
                    if (imageUrl.includes('cloudinary.com')) {
                        console.log('Successfully uploaded to Cloudinary:', imageUrl);

                        // Add Cloudinary indicator next to preview
                        const cloudinaryIndicator = document.createElement('span');
                        cloudinaryIndicator.textContent = ' (Cloudinary)';
                        cloudinaryIndicator.style.fontSize = '0.9em';
                        cloudinaryIndicator.style.color = '#28a745'; // Green for Cloudinary
                        cloudinaryIndicator.style.fontWeight = 'bold';

                        const previewImg = document.getElementById('product-image-preview');
                        if (previewImg.nextSibling && previewImg.nextSibling.tagName === 'SPAN') {
                            previewImg.parentNode.removeChild(previewImg.nextSibling);
                        }
                        previewImg.parentNode.insertBefore(cloudinaryIndicator, previewImg.nextSibling);
                    } else {
                        // It's a base64 string (fallback)
                        console.log('Using base64 image (Cloudinary upload failed)');

                        // Add fallback indicator next to preview
                        const fallbackIndicator = document.createElement('span');
                        fallbackIndicator.textContent = ' (Local Storage)';
                        fallbackIndicator.style.fontSize = '0.9em';
                        fallbackIndicator.style.color = '#ffc107'; // Yellow for fallback
                        fallbackIndicator.style.fontWeight = 'bold';

                        const previewImg = document.getElementById('product-image-preview');
                        if (previewImg.nextSibling && previewImg.nextSibling.tagName === 'SPAN') {
                            previewImg.parentNode.removeChild(previewImg.nextSibling);
                        }
                        previewImg.parentNode.insertBefore(fallbackIndicator, previewImg.nextSibling);
                    }

                } catch (error) {
                    console.error('Image upload failed:', error);

                    // Update status
                    if (document.getElementById('upload-status')) {
                        document.getElementById('upload-status').textContent = 'Upload failed: ' + error.message;
                        document.getElementById('upload-status').style.color = '#dc3545';
                    }

                    alert('Failed to upload image. Please try again with a different image.');
                    this.value = ''; // Clear the file input
                } finally {
                    hideLoading();

                    // Remove status after 5 seconds
                    setTimeout(() => {
                        if (document.getElementById('upload-status')) {
                            document.getElementById('upload-status').remove();
                        }
                    }, 5000);
                }
            }
        });

        // Function to upload image to Cloudinary using signed uploads
        async function uploadToCloudinary(file) {
            try {
                // Log file details
                console.log('Uploading file to Cloudinary:', file.name, 'Size:', Math.round(file.size/1024) + 'KB');

                // Generate a signature for signed uploads
                // Since we can't generate a proper signature in the browser (would require API secret),
                // we'll use a direct upload approach with your API key

                // Create a FormData object to send the file
                const formData = new FormData();
                formData.append('file', file);

                // Use a specific folder to make it easier to find uploads
                formData.append('folder', 'product_images');

                // Add your Cloudinary credentials
                formData.append('api_key', '374414837229234');

                // Add timestamp
                const timestamp = Math.floor(Date.now() / 1000).toString();
                formData.append('timestamp', timestamp);

                // Add a unique public_id to avoid conflicts
                const uniqueId = 'product_' + Date.now();
                formData.append('public_id', uniqueId);

                // Show upload progress in console
                console.log('Starting Cloudinary upload with API key...');

                // Upload to Cloudinary with longer timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout

                try {
                    const response = await fetch('https://api.cloudinary.com/v1_1/dtzhskby3/auto/upload', {
                        method: 'POST',
                        body: formData,
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId); // Clear the timeout

                    // Check for errors
                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('Cloudinary error response:', errorText);

                        // If we get an error about missing signature, we need to use base64
                        if (errorText.includes('signature')) {
                            console.log('Signature required. Falling back to base64...');
                            throw new Error('Signature required for upload');
                        }

                        throw new Error(`Cloudinary upload failed: ${response.status} ${response.statusText}`);
                    }

                    // Parse the response
                    const data = await response.json();
                    console.log('Cloudinary upload successful!', data);

                    // Log detailed information about the upload
                    console.log('Cloudinary upload details:');
                    console.log('- Public ID:', data.public_id);
                    console.log('- Format:', data.format);
                    console.log('- URL:', data.url);
                    console.log('- Secure URL:', data.secure_url);
                    console.log('- Original Filename:', data.original_filename);
                    console.log('- Created At:', new Date(data.created_at * 1000).toLocaleString());

                    // Create a popup notification with upload details
                    const notification = document.createElement('div');
                    notification.style.cssText = 'position:fixed; bottom:20px; left:20px; background:#28a745; color:#fff; padding:15px; border-radius:5px; box-shadow:0 2px 10px rgba(0,0,0,0.2); z-index:1000; max-width:400px;';
                    notification.innerHTML = `
                        <strong>Cloudinary Upload Success!</strong><br>
                        Public ID: ${data.public_id}<br>
                        URL: ${data.secure_url.substring(0, 50)}...<br>
                        Size: ${Math.round(data.bytes/1024)}KB<br>
                        Format: ${data.format}<br>
                        <small>Check the "product_images" folder in your Media Library</small>
                    `;
                    document.body.appendChild(notification);

                    // Remove notification after 10 seconds
                    setTimeout(() => {
                        notification.style.opacity = '0';
                        notification.style.transition = 'opacity 0.5s ease';
                        setTimeout(() => notification.remove(), 500);
                    }, 10000);

                    // Return the secure URL of the uploaded image
                    return data.secure_url;
                } catch (fetchError) {
                    clearTimeout(timeoutId); // Clear the timeout
                    throw fetchError;
                }
            } catch (error) {
                console.error('Error uploading to Cloudinary:', error);

                // If Cloudinary upload fails, fall back to base64 encoding
                console.log('Falling back to base64 encoding...');

                try {
                    // Convert to base64 without compression
                    const base64String = await fileToBase64(file);
                    console.log('Fallback to base64 successful');

                    return base64String;
                } catch (fallbackError) {
                    console.error('Fallback to base64 failed:', fallbackError);
                    throw error; // Throw the original error
                }
            }
        }

        // Helper function to load an image and get its dimensions
        function loadImage(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = function(event) {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onload = function() {
                        resolve(img);
                    };
                    img.onerror = function(error) {
                        reject(error);
                    };
                };
                reader.onerror = function(error) {
                    reject(error);
                };
            });
        }

        // Helper function to compress and resize an image with better quality preservation
        function compressImage(file, maxDimension, quality) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = function(event) {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onload = function() {
                        // Calculate new dimensions while preserving aspect ratio
                        let width = img.width;
                        let height = img.height;

                        // Determine which dimension to constrain
                        if (width > height) {
                            // Landscape image
                            if (width > maxDimension) {
                                height = Math.round(height * maxDimension / width);
                                width = maxDimension;
                            }
                        } else {
                            // Portrait or square image
                            if (height > maxDimension) {
                                width = Math.round(width * maxDimension / height);
                                height = maxDimension;
                            }
                        }

                        console.log('Resizing to:', width + 'x' + height, 'with quality:', quality);

                        // Create canvas for resizing
                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;

                        // Draw and compress image on canvas with better quality
                        const ctx = canvas.getContext('2d');
                        ctx.imageSmoothingEnabled = true;
                        ctx.imageSmoothingQuality = 'high';
                        ctx.drawImage(img, 0, 0, width, height);

                        // Convert to blob with compression
                        canvas.toBlob(function(blob) {
                            resolve(blob);
                        }, 'image/jpeg', quality); // Always use JPEG for better compression
                    };
                    img.onerror = function(error) {
                        reject(error);
                    };
                };
                reader.onerror = function(error) {
                    reject(error);
                };
            });
        }

        // Helper function to convert a file to base64
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(error);
            });
        }

        // Add/Edit Product (DB version)
        document.getElementById('product-form').onsubmit = async function(e) {
            e.preventDefault();

            // Show loading indicator
            showLoading();

            const id = document.getElementById('product-id').value;
            const name = document.getElementById('product-name').value.trim();
            let image = document.getElementById('product-image').value.trim();
            const desc = document.getElementById('product-desc').value.trim();
            const price = document.getElementById('product-price').value.trim();

            // Validate inputs
            if (!name) {
                alert('Product name is required');
                hideLoading();
                return;
            }

            if (!price || isNaN(price) || price <= 0) {
                alert('Please enter a valid price');
                hideLoading();
                return;
            }

            // Log image information
            if (image) {
                if (image.includes('cloudinary.com')) {
                    console.log('Submitting product with Cloudinary URL:', image);
                } else {
                    // It's a base64 string
                    const sizeKB = Math.round(image.length/1024);
                    console.log('Submitting product with base64 image, size:', sizeKB + 'KB');
                }
            }

            try {
                // Prepare the product data
                const productData = { name, desc, price };

                // Only include image if it's not empty
                if (image) {
                    productData.image = image;
                }

                if (id) {
                    // Update
                    const response = await fetch(`https://tridex1.onrender.com/products/${id}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(productData)
                    });

                    if (!response.ok) {
                        if (response.status === 413) {
                            throw new Error('The image is too large for the server to process. Please use a smaller image.');
                        } else {
                            throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                        }
                    }

                    // Log the response for debugging
                    const responseData = await response.json();
                    console.log('Product update response:', responseData);

                    alert('Product updated successfully!');
                } else {
                    // Add
                    const response = await fetch('https://tridex1.onrender.com/products', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(productData)
                    });

                    if (!response.ok) {
                        if (response.status === 413) {
                            throw new Error('The image is too large for the server to process. Please use a smaller image.');
                        } else {
                            throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                        }
                    }

                    // Log the response for debugging
                    const responseData = await response.json();
                    console.log('Product add response:', responseData);

                    alert('Product added successfully!');
                }

                // Reset form
                this.reset();
                document.getElementById('product-save-btn').textContent = 'Add Product';
                document.getElementById('product-cancel-btn').style.display = 'none';
                document.getElementById('product-image-preview').style.display = 'none';
                document.getElementById('product-image').value = '';

                // Refresh product list
                fetchProducts();
            } catch (e) {
                console.error('Product operation failed:', e);
                alert(`Failed to ${id ? 'update' : 'add'} product: ${e.message}`);
            } finally {
                hideLoading();
            }
        };
        // Cancel edit
        document.getElementById('product-cancel-btn').onclick = function() {
            document.getElementById('product-form').reset();
            document.getElementById('product-save-btn').textContent = 'Add Product';
            this.style.display = 'none';
            document.getElementById('product-image-preview').style.display = 'none';
            document.getElementById('product-image').value = '';
        };

        // --- Announcement Management (DB version) ---
        async function fetchAnnouncements() {
            try {
                const res = await fetch('https://tridex1.onrender.com/announcements');
                announcements = await res.json();
                renderAdminMessages();
            } catch (e) {
                announcements = [];
                renderAdminMessages();
                alert('Failed to load announcements from database.');
            }
        }
        document.getElementById('admin-mail-form').onsubmit = async function(e) {
            e.preventDefault();

            // Show loading indicator
            showLoading();

            const title = document.getElementById('mail-title').value.trim();
            const message = document.getElementById('mail-body').value.trim();

            // Validate inputs
            if (!title) {
                alert('Announcement title is required');
                hideLoading();
                return;
            }

            if (!message) {
                alert('Announcement message is required');
                hideLoading();
                return;
            }

            try {
                const response = await fetch('https://tridex1.onrender.com/announcements', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title, message })
                });

                if (!response.ok) {
                    throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                }

                alert('Announcement sent successfully!');
                document.getElementById('admin-mail-modal').style.display = 'none';
                this.reset();
                fetchAnnouncements();
            } catch (e) {
                console.error('Failed to send announcement:', e);
                alert(`Failed to send announcement: ${e.message}`);
            } finally {
                hideLoading();
            }
        };
        function renderAdminMessages() {
            const messagesDiv = document.getElementById('admin-mailbox-messages');
            if (!announcements || announcements.length === 0) {
                messagesDiv.innerHTML = '<p style="color:#888;">No messages.</p>';
            } else {
                messagesDiv.innerHTML = announcements.map((msg, idx) =>
                    `<div style="border-bottom:1px solid #eee; padding:8px 0;">
                        <strong>${msg.title || 'Announcement'}</strong>
                        <div style="font-size:0.97em; margin-top:4px;">${msg.message}</div>
                        <div style="font-size:0.85em; color:#888; margin-top:2px;">${new Date(msg.createdAt).toLocaleString() || ''}</div>
                        <button class="delete-msg-btn" data-id="${msg._id}" style="margin-top:6px; padding:4px 12px; background:#dc3545; color:#fff; border:none; border-radius:4px; font-size:0.95em; cursor:pointer;">Delete</button>
                    </div>`
                ).join('');
                // Add delete handlers
                messagesDiv.querySelectorAll('.delete-msg-btn').forEach(btn => {
                    btn.onclick = async function() {
                        const id = this.getAttribute('data-id');
                        if (confirm('Delete this message?')) {
                            // Show loading indicator
                            showLoading();

                            try {
                                const response = await fetch(`https://tridex1.onrender.com/announcements/${id}`, { method: 'DELETE' });

                                if (!response.ok) {
                                    throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                                }

                                fetchAnnouncements();
                            } catch (e) {
                                console.error('Failed to delete announcement:', e);
                                alert(`Failed to delete announcement: ${e.message}`);
                            } finally {
                                hideLoading();
                            }
                        }
                    };
                });
            }
        }
        // Show mailbox modal and fetch announcements
        document.getElementById('show-mail-btn').onclick = function() {
            document.getElementById('admin-mail-modal').style.display = 'flex';
            fetchAnnouncements();
        };
        document.getElementById('close-admin-mail').onclick = function() {
            document.getElementById('admin-mail-modal').style.display = 'none';
        };

        // --- Navigation between sections ---
        document.getElementById('show-users-btn').onclick = function() {
            document.getElementById('user-section').style.display = '';
            document.getElementById('product-section').style.display = 'none';
            document.getElementById('show-users-btn').classList.add('active');
            document.getElementById('show-products-btn').classList.remove('active');
        };
        document.getElementById('show-products-btn').onclick = function() {
            document.getElementById('user-section').style.display = 'none';
            document.getElementById('product-section').style.display = '';
            document.getElementById('show-products-btn').classList.add('active');
            document.getElementById('show-users-btn').classList.remove('active');
        };

        function showLoading() {
            document.getElementById('loading-overlay').style.display = 'flex';
        }
        function hideLoading() {
            document.getElementById('loading-overlay').style.display = 'none';
        }
        window.addEventListener('load', function() {
            hideLoading();
        });
        window.addEventListener('beforeunload', function() {
            showLoading();
        });

        // Debug ban system button
        document.getElementById('debug-ban-system').addEventListener('click', function() {
            if (window.banSystem) {
                const bannedUsers = window.banSystem.debugBanSystem();
                document.getElementById('debug-output').textContent =
                    bannedUsers.length > 0 ?
                    `Banned users: ${bannedUsers.join(', ')}` :
                    'No banned users found';
            } else {
                document.getElementById('debug-output').textContent = 'Ban system not available';
            }
        });

        // Function to check Cloudinary connection and verify uploads
        async function checkCloudinaryConnection() {
            try {
                // Update status
                const statusSpan = document.getElementById('cloudinary-status');
                if (statusSpan) {
                    statusSpan.textContent = 'Testing connection...';
                    statusSpan.style.color = '#007bff';
                }

                // Create a small test image (1x1 pixel transparent PNG)
                const base64Image = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';

                // Convert base64 to blob
                const response = await fetch(base64Image);
                const blob = await response.blob();
                const file = new File([blob], 'cloudinary_test.png', { type: 'image/png' });

                // Try to upload to Cloudinary
                console.log('Testing Cloudinary connection with a small test image...');

                // Create a special test FormData with API key for signed uploads
                const formData = new FormData();
                formData.append('file', file);
                formData.append('folder', 'test_uploads');
                formData.append('public_id', 'connection_test_' + Date.now());

                // Add your Cloudinary credentials
                formData.append('api_key', '374414837229234');

                // Add timestamp
                const timestamp = Math.floor(Date.now() / 1000).toString();
                formData.append('timestamp', timestamp);

                // Try the upload directly
                const uploadResponse = await fetch('https://api.cloudinary.com/v1_1/dtzhskby3/auto/upload', {
                    method: 'POST',
                    body: formData
                });

                if (!uploadResponse.ok) {
                    const errorText = await uploadResponse.text();
                    console.error('Cloudinary test upload failed:', errorText);

                    // Try to create an upload preset
                    console.log('Attempting to use signed upload instead...');

                    // Use our regular upload function as fallback
                    const imageUrl = await uploadToCloudinary(file);

                    if (imageUrl.includes('cloudinary.com')) {
                        // Success with fallback
                        if (statusSpan) {
                            statusSpan.textContent = 'Connected using fallback method';
                            statusSpan.style.color = '#ffc107';
                        }

                        // Add a warning notification
                        const notification = document.createElement('div');
                        notification.style.cssText = 'position:fixed; bottom:20px; right:20px; background:#ffc107; color:#000; padding:10px 15px; border-radius:5px; box-shadow:0 2px 10px rgba(0,0,0,0.2); z-index:1000;';
                        notification.innerHTML = `
                            <strong>Cloudinary Connected (Fallback)</strong><br>
                            Test image uploaded successfully using fallback method.<br>
                            <small>Check the "product_images" folder in your Media Library.</small>
                        `;
                        document.body.appendChild(notification);

                        // Remove the notification after 10 seconds
                        setTimeout(() => {
                            notification.style.opacity = '0';
                            notification.style.transition = 'opacity 0.5s ease';
                            setTimeout(() => notification.remove(), 500);
                        }, 10000);

                        return true;
                    } else {
                        throw new Error('Both direct and fallback upload methods failed');
                    }
                }

                // Parse the successful response
                const data = await uploadResponse.json();
                console.log('âœ… Cloudinary connection test successful!', data);

                // Update status
                if (statusSpan) {
                    statusSpan.textContent = 'Connected to Cloudinary';
                    statusSpan.style.color = '#28a745';
                }

                // Add a success notification
                const notification = document.createElement('div');
                notification.style.cssText = 'position:fixed; bottom:20px; right:20px; background:#28a745; color:#fff; padding:10px 15px; border-radius:5px; box-shadow:0 2px 10px rgba(0,0,0,0.2); z-index:1000;';
                notification.innerHTML = `
                    <strong>Cloudinary Connected!</strong><br>
                    Test image uploaded successfully.<br>
                    <small>Check the "test_uploads" folder in your Media Library.</small>
                `;
                document.body.appendChild(notification);

                // Remove the notification after 10 seconds
                setTimeout(() => {
                    notification.style.opacity = '0';
                    notification.style.transition = 'opacity 0.5s ease';
                    setTimeout(() => notification.remove(), 500);
                }, 10000);

                return true;
            } catch (error) {
                console.error('Cloudinary connection test failed:', error);

                // Update status
                const statusSpan = document.getElementById('cloudinary-status');
                if (statusSpan) {
                    statusSpan.textContent = 'Connection failed';
                    statusSpan.style.color = '#dc3545';
                }

                // Add an error notification
                const notification = document.createElement('div');
                notification.style.cssText = 'position:fixed; bottom:20px; right:20px; background:#dc3545; color:#fff; padding:10px 15px; border-radius:5px; box-shadow:0 2px 10px rgba(0,0,0,0.2); z-index:1000;';
                notification.innerHTML = `
                    <strong>Cloudinary Connection Failed</strong><br>
                    Error: ${error.message}<br>
                    <small>Check console for details.</small>
                `;
                document.body.appendChild(notification);

                // Remove the notification after 10 seconds
                setTimeout(() => {
                    notification.style.opacity = '0';
                    notification.style.transition = 'opacity 0.5s ease';
                    setTimeout(() => notification.remove(), 500);
                }, 10000);

                return false;
            }
        }

        // Function to verify if product images are stored in Cloudinary
        async function verifyProductImages() {
            try {
                // Show loading indicator
                showLoading();

                // Fetch all products
                const response = await fetch('https://tridex1.onrender.com/products');
                if (!response.ok) {
                    throw new Error(`Failed to fetch products: ${response.status} ${response.statusText}`);
                }

                const products = await response.json();
                console.log(`Verifying ${products.length} products for Cloudinary images...`);

                // Count Cloudinary vs base64 images
                let cloudinaryCount = 0;
                let base64Count = 0;
                let noImageCount = 0;

                // Check each product
                products.forEach(product => {
                    if (!product.image) {
                        noImageCount++;
                    } else if (product.image.includes('cloudinary.com')) {
                        cloudinaryCount++;
                    } else if (product.image.startsWith('data:image')) {
                        base64Count++;
                    } else {
                        console.log('Unknown image format for product:', product.name);
                    }
                });

                // Create a report
                const report = document.createElement('div');
                report.style.cssText = 'position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:#fff; color:#333; padding:20px; border-radius:5px; box-shadow:0 5px 15px rgba(0,0,0,0.3); z-index:1001; max-width:500px;';
                report.innerHTML = `
                    <h4>Product Image Report</h4>
                    <p>Total Products: ${products.length}</p>
                    <p style="color:#28a745;"><strong>Cloudinary Images:</strong> ${cloudinaryCount}</p>
                    <p style="color:#ffc107;"><strong>Base64 Images:</strong> ${base64Count}</p>
                    <p><strong>No Images:</strong> ${noImageCount}</p>
                    <p>To see Cloudinary images in your Media Library, make sure you're logged in to the correct account.</p>
                    <button class="btn btn-primary" onclick="this.parentNode.remove()">Close</button>
                `;
                document.body.appendChild(report);

                console.log('Image verification complete:');
                console.log('- Cloudinary images:', cloudinaryCount);
                console.log('- Base64 images:', base64Count);
                console.log('- No images:', noImageCount);

            } catch (error) {
                console.error('Error verifying product images:', error);
                alert('Failed to verify product images: ' + error.message);
            } finally {
                hideLoading();
            }
        }

        // Add event listeners for Cloudinary verification buttons
        document.getElementById('verify-cloudinary-btn').addEventListener('click', function() {
            checkCloudinaryConnection();
        });

        document.getElementById('verify-product-images-btn').addEventListener('click', function() {
            verifyProductImages();
        });

        // On load
        fetchUsers();
        fetchProducts();
    </script>
</body>
</html>
