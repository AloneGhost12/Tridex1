<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Panel</title>
    <link rel="stylesheet" href="style.css">
    <!-- Include the ban system script -->
    <script src="ban-system.js"></script>
    <style>
        table { border-collapse: collapse; width: 100%; margin-top: 24px; }
        th, td { border: 1px solid #ccc; padding: 8px 12px; text-align: left; }
        th { background: #f8f8f8; }
        .ban-btn, .unban-btn, .delete-btn {
            padding: 5px 14px;
            border: none;
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            margin-right: 6px;
        }
        .ban-btn { background: #dc3545; }
        .unban-btn { background: #28a745; }
        .delete-btn { background: #888; }
        /* Modal styles */
        #user-detail-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.3);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }
        #user-detail-modal > div {
            background: #fff;
            padding: 32px 24px;
            border-radius: 8px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.15);
            min-width: 300px;
            max-width: 90vw;
        }
        /* Product admin styles */
        #product-form input, #product-form textarea { margin-bottom: 8px; display: block; width: 100%; }
        #product-list img { max-width: 60px; max-height: 60px; }
        .edit-btn { background: #007bff; color: #fff; border: none; border-radius: 4px; padding: 5px 14px; cursor: pointer; margin-right: 6px; }
        .admin-nav-btn {
            padding: 8px 18px;
            margin-right: 10px;
            background: #007bff;
            color: #fff;
            border: none;
            border-radius: 5px;
            font-size: 1rem;
            cursor: pointer;
        }
        .admin-nav-btn.active {
            background: #0056b3;
        }
        @keyframes spin {
            0% { transform: rotate(0deg);}
            100% { transform: rotate(360deg);}
        }
    </style>
</head>
<body>
    <!-- Loading animation overlay -->
    <div id="loading-overlay" style="display:flex; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(255,255,255,0.7); z-index:99999; align-items:center; justify-content:center;">
        <div style="border:6px solid #f3f3f3; border-top:6px solid #007bff; border-radius:50%; width:48px; height:48px; animation:spin 1s linear infinite;"></div>
    </div>
    <h1>Admin Panel</h1>
    <!-- Admin controls -->
    <div class="admin-controls" style="margin-bottom:15px;">
        <button id="verify-cloudinary-btn" class="btn btn-info btn-sm" style="padding:5px 10px; background:#17a2b8; color:white; border:none; border-radius:4px; cursor:pointer; margin-right:10px;">Check Cloudinary Connection</button>
        <button id="verify-product-images-btn" class="btn btn-info btn-sm" style="padding:5px 10px; background:#6c757d; color:white; border:none; border-radius:4px; cursor:pointer;">Verify Product Images</button>
        <span id="cloudinary-status" style="margin-left:10px; font-size:0.9em;"></span>
    </div>

    <!-- Admin navigation buttons -->
    <div style="margin-bottom:24px;">
        <button class="admin-nav-btn active" id="show-users-btn">User Details</button>
        <button class="admin-nav-btn" id="show-products-btn">Product Management</button>
        <button class="admin-nav-btn" id="show-categories-btn">Categories</button>
        <button class="admin-nav-btn" id="show-mail-btn" title="Send Announcement">&#9993; Mail</button>
    </div>

    <!-- User Details Section -->
    <div id="user-section">
        <div style="margin-bottom: 15px;">
            <button id="debug-ban-system" style="padding: 8px 15px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">Debug Ban System</button>
            <span id="debug-output" style="margin-left: 10px; font-family: monospace;"></span>
        </div>
        <table id="user-table">
            <thead>
                <tr>
                    <th>Username</th>
                    <th>Email</th>
                    <th>Phone</th>
                    <th>Age</th>
                    <th>Password</th>
                    <th>Status</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody>
                <!-- User rows will be rendered here -->
            </tbody>
        </table>
        <!-- User detail modal -->
        <div id="user-detail-modal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.3); z-index:2000; align-items:center; justify-content:center;">
            <div style="background:#fff; padding:32px 24px; border-radius:8px; box-shadow:0 2px 12px rgba(0,0,0,0.15); min-width:300px; max-width:90vw;">
                <h2>User Details</h2>
                <div id="user-detail-content"></div>
                <button id="close-user-detail" style="margin-top:18px; padding:8px 18px; background:#007bff; color:#fff; border:none; border-radius:5px; font-size:1rem; cursor:pointer;">Close</button>
            </div>
        </div>
    </div>

    <!-- Product Management Section -->
    <div id="product-section" style="display:none;">
        <form id="product-form">
            <input type="hidden" id="product-id">
            <label>Product Name: <input type="text" id="product-name" required></label>
            <!-- Image upload and preview -->
            <label>Image: <input type="file" id="product-image-file" accept="image/*"></label>
            <input type="hidden" id="product-image">
            <img id="product-image-preview" src="" alt="Preview" style="display:none;max-width:80px;max-height:80px;margin-bottom:8px;">
            <label>Description: <textarea id="product-desc" required></textarea></label>
            <label>Price: <input type="number" id="product-price" min="1" required></label>
            <label>Category:
                <select id="product-category">
                    <option value="">-- Select Category --</option>
                    <!-- Categories will be loaded dynamically -->
                </select>
            </label>
            <button type="submit" id="product-save-btn">Add Product</button>
            <button type="button" id="product-cancel-btn" style="display:none;">Cancel</button>
        </form>
        <table id="product-list">
            <thead>
                <tr>
                    <th>Photo</th>
                    <th>Name</th>
                    <th>Description</th>
                    <th>Price</th>
                    <th>Category</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody>
                <!-- Product rows will be rendered here -->
            </tbody>
        </table>
    </div>

    <!-- Category Management Section -->
    <div id="category-section" style="display:none;">
        <form id="category-form">
            <input type="hidden" id="category-id">
            <label>Category Name: <input type="text" id="category-name" required></label>
            <!-- Icon upload and preview -->
            <label>Icon: <input type="file" id="category-icon-file" accept="image/*"></label>
            <input type="hidden" id="category-icon">
            <img id="category-icon-preview" src="" alt="Preview" style="display:none;max-width:80px;max-height:80px;margin-bottom:8px;">
            <label>Description: <textarea id="category-desc"></textarea></label>
            <button type="submit" id="category-save-btn">Add Category</button>
            <button type="button" id="category-cancel-btn" style="display:none;">Cancel</button>
        </form>
        <table id="category-list">
            <thead>
                <tr>
                    <th>Icon</th>
                    <th>Name</th>
                    <th>Description</th>
                    <th>Products</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody>
                <!-- Category rows will be rendered here -->
            </tbody>
        </table>
    </div>

    <!-- Mailbox Modal for Admin -->
    <div id="admin-mail-modal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.3); z-index:3000; align-items:center; justify-content:center;">
        <div style="background:#fff; padding:32px 24px; border-radius:8px; box-shadow:0 2px 12px rgba(0,0,0,0.15); min-width:320px; max-width:90vw;">
            <h2 style="margin-top:0;">Send Announcement</h2>
            <form id="admin-mail-form">
                <label>Title: <input type="text" id="mail-title" required></label><br>
                <label>Message:<br>
                    <textarea id="mail-body" required style="width:100%;height:80px;"></textarea>
                </label><br>
                <button type="submit" style="padding:8px 18px; background:#007bff; color:#fff; border:none; border-radius:5px; font-size:1rem; cursor:pointer;">Send</button>
                <button type="button" id="close-admin-mail" style="padding:8px 18px; background:#888; color:#fff; border:none; border-radius:5px; font-size:1rem; cursor:pointer; margin-left:10px;">Cancel</button>
            </form>
            <hr style="margin:18px 0;">
            <h3>All Announcements</h3>
            <div id="admin-mailbox-messages" style="max-height:300px; overflow-y:auto; margin-bottom:10px;"></div>
        </div>
    </div>

    <script>
        // --- Simple login protection: redirect to login.html if not logged in ---
        if (!localStorage.getItem('token')) {
            window.location.href = 'login.html';
        }
        // Enforce admin-only access
        if (localStorage.getItem('isAdmin') !== 'true') {
            window.location.href = 'index.html';
        }

        // Function to get Cloudinary configuration from server
        async function getCloudinaryConfig() {
            try {
                // First try the production server
                let response;
                try {
                    response = await fetch('https://tridex1.onrender.com/cloudinary-config');
                } catch (fetchError) {
                    console.warn('Could not reach production server, trying local server...');
                    // If production server fails, try local server
                    response = await fetch('http://localhost:3000/cloudinary-config');
                }

                if (!response.ok) {
                    throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();

                if (!data.cloudName || data.cloudName === 'your_cloud_name') {
                    throw new Error('Cloudinary cloud name not properly configured on the server');
                }

                // Check if API key is missing
                if (!data.apiKey) {
                    console.error('Cloudinary API key not provided by the server');
                    console.error('Please check your server .env file and make sure it contains a valid CLOUDINARY_API_KEY');

                    // Show a more detailed error message
                    const errorDiv = document.createElement('div');
                    errorDiv.style.cssText = 'position:fixed; top:20px; right:20px; background:#f8d7da; color:#721c24; padding:15px; border-radius:5px; box-shadow:0 2px 10px rgba(0,0,0,0.2); z-index:1000; max-width:400px;';
                    errorDiv.innerHTML = `
                        <h3 style="margin-top:0;">Cloudinary Configuration Error</h3>
                        <p>The API key is missing from the server configuration.</p>
                        <p>Images will be stored as base64 until this is fixed.</p>
                        <p><strong>To fix this:</strong></p>
                        <ol>
                            <li>Check your server's .env file</li>
                            <li>Make sure CLOUDINARY_API_KEY is set correctly</li>
                            <li>Restart the server</li>
                        </ol>
                        <button onclick="this.parentNode.remove()" style="padding:5px 10px; background:#721c24; color:white; border:none; border-radius:3px; cursor:pointer;">Close</button>
                    `;
                    document.body.appendChild(errorDiv);
                }

                console.log('Successfully retrieved Cloudinary configuration');
                return data;
            } catch (error) {
                console.error('Error fetching Cloudinary config:', error);

                // Show a more detailed error message
                const errorDiv = document.createElement('div');
                errorDiv.style.cssText = 'position:fixed; top:20px; right:20px; background:#f8d7da; color:#721c24; padding:15px; border-radius:5px; box-shadow:0 2px 10px rgba(0,0,0,0.2); z-index:1000; max-width:400px;';
                errorDiv.innerHTML = `
                    <h3 style="margin-top:0;">Cloudinary Configuration Error</h3>
                    <p>${error.message}</p>
                    <p>Images will be stored as base64 until this is fixed.</p>
                    <p><strong>To fix this:</strong></p>
                    <ol>
                        <li>Check your server's .env file</li>
                        <li>Make sure CLOUDINARY_CLOUD_NAME and CLOUDINARY_API_KEY are set correctly</li>
                        <li>Restart the server</li>
                    </ol>
                    <button onclick="this.parentNode.remove()" style="padding:5px 10px; background:#721c24; color:white; border:none; border-radius:3px; cursor:pointer;">Close</button>
                `;
                document.body.appendChild(errorDiv);

                // Fallback to a placeholder - this will fail but won't expose credentials
                return { cloudName: 'your_cloud_name', apiKey: 'missing_api_key' };
            }
        }

        // Make sure isLoggedIn flag is set (needed for cart and mailbox access)
        if (localStorage.getItem('token') && !localStorage.getItem('isLoggedIn')) {
            localStorage.setItem('isLoggedIn', 'true');
        }

        // Make sure currentUser is set (needed for cart functionality)
        if (!localStorage.getItem('currentUser') && localStorage.getItem('username')) {
            localStorage.setItem('currentUser', localStorage.getItem('username'));
        }

        let users = [];
        let products = [];
        let announcements = [];

        // Load users from backend
        async function fetchUsers() {
            try {
                const res = await fetch('https://tridex1.onrender.com/users');
                users = await res.json();
                renderUsers();
            } catch (e) {
                users = [];
                renderUsers();
                alert('Failed to load users from database.');
            }
        }

        function renderUsers() {
            const tbody = document.querySelector('#user-table tbody');
            tbody.innerHTML = '';
            users.forEach(user => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td class="username-link" style="color:#007bff; cursor:pointer; text-decoration:underline; text-transform:uppercase; letter-spacing:0.5px; font-weight:500;">
                        ${user.username || ''} ${user.verified ? '<span title="Verified" style="color:#1da1f2; font-size:1.1em;vertical-align:middle;">&#10004;&#65039;</span>' : ''}
                    </td>
                    <td>${user.email || ''}</td>
                    <td>${user.phone || ''}</td>
                    <td>${user.age || ''}</td>
                    <td>${user.password || ''}</td>
                    <td>${user.banned ? '<span style="color:red;">Banned</span>' : 'Active'}</td>
                    <td>
                        <button type="button" class="ban-btn"${user.banned ? ' style="display:none;"' : ''}>Ban</button>
                        <button type="button" class="unban-btn"${!user.banned ? ' style="display:none;"' : ''}>Unban</button>
                        <button type="button" class="delete-btn">Delete</button>
                        <button type="button" class="verify-btn"${user.verified ? ' style="display:none;"' : ''} style="background:#1da1f2; color:white; border:none; border-radius:4px; padding:5px 14px; cursor:pointer; margin-right:6px;">Verify</button>
                        <button type="button" class="unverify-btn"${!user.verified ? ' style="display:none;"' : ''} style="background:#6c757d; color:white; border:none; border-radius:4px; padding:5px 14px; cursor:pointer;">Unverify</button>
                    </td>
                `;
                // Show user details on username click
                tr.querySelector('.username-link').onclick = function() {
                    showUserDetail(user);
                };
                // Ban user (update DB in real app)
                tr.querySelector('.ban-btn').onclick = async function() {
                    if (confirm(`Ban ${user.username}?`)) {
                        try {
                            // Show loading indicator
                            showLoading();

                            // Call the server to ban the user
                            const response = await fetch(`https://tridex1.onrender.com/users/${user._id}/ban`, { method: 'PUT' });

                            // Log server response
                            console.log(`Server ban response for ${user.username}:`, response.status);

                            // Also ban the user locally using our ban system
                            if (window.banSystem) {
                                const result = window.banSystem.banUser(user.username);
                                console.log(`User ${user.username} ban result: ${result ? 'success' : 'failed'}`);

                                // Update the debug output
                                const bannedUsers = window.banSystem.debugBanSystem();
                                document.getElementById('debug-output').textContent =
                                    bannedUsers.length > 0 ?
                                    `Banned users: ${bannedUsers.join(', ')}` :
                                    'No banned users found';
                            }

                            // Update the UI to show the user is now banned
                            const statusCell = tr.querySelector('td:nth-child(6)');
                            if (statusCell) {
                                statusCell.innerHTML = '<span style="color:red;">Banned</span>';
                            }

                            // Hide the ban button and show the unban button
                            tr.querySelector('.ban-btn').style.display = 'none';
                            tr.querySelector('.unban-btn').style.display = '';

                            // Refresh the user list
                            fetchUsers();
                        } catch (e) {
                            console.error('Failed to ban user on server:', e);

                            // If server fails, still ban locally
                            if (window.banSystem) {
                                const result = window.banSystem.banUser(user.username);
                                console.log(`User ${user.username} local ban result: ${result ? 'success' : 'failed'}`);

                                // Update the debug output
                                const bannedUsers = window.banSystem.debugBanSystem();
                                document.getElementById('debug-output').textContent =
                                    bannedUsers.length > 0 ?
                                    `Banned users: ${bannedUsers.join(', ')}` :
                                    'No banned users found';

                                // Update the UI to show the user is now banned
                                const statusCell = tr.querySelector('td:nth-child(6)');
                                if (statusCell) {
                                    statusCell.innerHTML = '<span style="color:red;">Banned</span>';
                                }

                                // Hide the ban button and show the unban button
                                tr.querySelector('.ban-btn').style.display = 'none';
                                tr.querySelector('.unban-btn').style.display = '';

                                // Refresh the user list
                                fetchUsers();
                            } else {
                                alert('Failed to ban user.');
                            }
                        } finally {
                            // Hide loading indicator
                            hideLoading();
                        }
                    }
                };
                // Unban user (update DB in real app)
                tr.querySelector('.unban-btn').onclick = async function() {
                    if (confirm(`Unban ${user.username}?`)) {
                        try {
                            // Show loading indicator
                            showLoading();

                            // Call the server to unban the user
                            const response = await fetch(`https://tridex1.onrender.com/users/${user._id}/unban`, { method: 'PUT' });

                            // Log server response
                            console.log(`Server unban response for ${user.username}:`, response.status);

                            // Also unban the user locally using our ban system
                            if (window.banSystem) {
                                const result = window.banSystem.unbanUser(user.username);
                                console.log(`User ${user.username} unban result: ${result ? 'success' : 'failed'}`);

                                // Update the debug output
                                const bannedUsers = window.banSystem.debugBanSystem();
                                document.getElementById('debug-output').textContent =
                                    bannedUsers.length > 0 ?
                                    `Banned users: ${bannedUsers.join(', ')}` :
                                    'No banned users found';
                            }

                            // Update the UI to show the user is now unbanned
                            const statusCell = tr.querySelector('td:nth-child(6)');
                            if (statusCell) {
                                statusCell.innerHTML = 'Active';
                            }

                            // Show the ban button and hide the unban button
                            tr.querySelector('.ban-btn').style.display = '';
                            tr.querySelector('.unban-btn').style.display = 'none';

                            // Refresh the user list
                            fetchUsers();
                        } catch (e) {
                            console.error('Failed to unban user on server:', e);

                            // If server fails, still unban locally
                            if (window.banSystem) {
                                const result = window.banSystem.unbanUser(user.username);
                                console.log(`User ${user.username} local unban result: ${result ? 'success' : 'failed'}`);

                                // Update the debug output
                                const bannedUsers = window.banSystem.debugBanSystem();
                                document.getElementById('debug-output').textContent =
                                    bannedUsers.length > 0 ?
                                    `Banned users: ${bannedUsers.join(', ')}` :
                                    'No banned users found';

                                // Update the UI to show the user is now unbanned
                                const statusCell = tr.querySelector('td:nth-child(6)');
                                if (statusCell) {
                                    statusCell.innerHTML = 'Active';
                                }

                                // Show the ban button and hide the unban button
                                tr.querySelector('.ban-btn').style.display = '';
                                tr.querySelector('.unban-btn').style.display = 'none';

                                // Refresh the user list
                                fetchUsers();
                            } else {
                                alert('Failed to unban user.');
                            }
                        } finally {
                            // Hide loading indicator
                            hideLoading();
                        }
                    }
                };
                // Delete user (update DB in real app)
                tr.querySelector('.delete-btn').onclick = async function() {
                    if (confirm(`Delete ${user.username}?`)) {
                        try {
                            await fetch(`https://tridex1.onrender.com/users/${user._id}`, { method: 'DELETE' });
                            fetchUsers();
                        } catch (e) { alert('Failed to delete user.'); }
                    }
                };
                // Verify user
                tr.querySelector('.verify-btn').onclick = async function() {
                    try {
                        showLoading();
                        await fetch(`https://tridex1.onrender.com/users/${user._id}/verify`, { method: 'PUT' });

                        // Create a verification announcement for the user
                        const verificationMessage = {
                            title: "Account Verified! ✓",
                            message: `Congratulations ${user.username}! Your account has been verified by an administrator. You now have a verified badge on your profile.`,
                            forUser: user.username
                        };

                        // Send the verification announcement
                        await fetch('https://tridex1.onrender.com/announcements', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(verificationMessage)
                        });

                        fetchUsers();
                    } catch (e) {
                        console.error('Failed to verify user:', e);
                        alert('Failed to verify user.');
                    } finally {
                        hideLoading();
                    }
                };

                // Unverify user
                tr.querySelector('.unverify-btn').onclick = async function() {
                    try {
                        showLoading();
                        await fetch(`https://tridex1.onrender.com/users/${user._id}/unverify`, { method: 'PUT' });
                        fetchUsers();
                    } catch (e) {
                        console.error('Failed to unverify user:', e);
                        alert('Failed to unverify user.');
                    } finally {
                        hideLoading();
                    }
                };
                tbody.appendChild(tr);
            });
        }

        function showUserDetail(user) {
            const modal = document.getElementById('user-detail-modal');
            const content = document.getElementById('user-detail-content');
            // Show all fields dynamically
            let html = '';
            for (const key in user) {
                if (user.hasOwnProperty(key)) {
                    html += `<p><strong>${key.charAt(0).toUpperCase() + key.slice(1)}:</strong> ${user[key]}</p>`;
                }
            }
            content.innerHTML = html;
            modal.style.display = 'flex';
        }

        document.getElementById('close-user-detail').onclick = function() {
            document.getElementById('user-detail-modal').style.display = 'none';
        };

        // --- Product Management (DB version) ---
        async function fetchProducts() {
            try {
                const res = await fetch('https://tridex1.onrender.com/products');
                products = await res.json();
                renderProducts();
            } catch (e) {
                products = [];
                renderProducts();
                alert('Failed to load products from database.');
            }
        }
        function renderProducts() {
            const tbody = document.querySelector('#product-list tbody');
            tbody.innerHTML = '';
            (products || []).forEach(product => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td><img src="${product.image || ''}" alt="${product.name}" style="cursor:pointer;" class="product-img" data-id="${product._id}"></td>
                    <td>${product.name}</td>
                    <td>${product.desc}</td>
                    <td>₹${product.price}</td>
                    <td>
                        <button class="edit-btn" data-id="${product._id}">Edit</button>
                        <button class="delete-btn" data-id="${product._id}">Delete</button>
                    </td>
                `;
                tr.querySelector('.product-img').onclick = function() {
                    window.location.href = `product-details.html?id=${product._id}`;
                };
                tr.querySelector('.edit-btn').onclick = function() {
                    setProductForm(product);
                };
                tr.querySelector('.delete-btn').onclick = async function() {
                    if (confirm('Delete this product?')) {
                        try {
                            await fetch(`https://tridex1.onrender.com/products/${product._id}`, { method: 'DELETE' });
                            fetchProducts();
                        } catch (e) { alert('Failed to delete product.'); }
                    }
                };
                tbody.appendChild(tr);
            });
        }
        // Set form fields for editing, including image preview
        function setProductForm(product) {
            document.getElementById('product-id').value = product._id;
            document.getElementById('product-name').value = product.name;
            document.getElementById('product-image').value = product.image;
            document.getElementById('product-desc').value = product.desc;
            document.getElementById('product-price').value = product.price;
            document.getElementById('product-save-btn').textContent = 'Update Product';
            document.getElementById('product-cancel-btn').style.display = '';
            if (product.image) {
                document.getElementById('product-image-preview').src = product.image;
                document.getElementById('product-image-preview').style.display = '';
            } else {
                document.getElementById('product-image-preview').style.display = 'none';
            }
            document.getElementById('product-image-file').value = '';
        }
        // Handle image file upload and processing
        document.getElementById('product-image-file').addEventListener('change', async function(e) {
            const file = e.target.files[0];
            if (file) {
                // Check file size (limit to 10MB for Cloudinary's free tier)
                if (file.size > 10 * 1024 * 1024) {
                    alert('Image size exceeds 10MB, which is Cloudinary\'s limit. Please choose a smaller image.');
                    this.value = ''; // Clear the file input
                    return;
                }

                // Show loading indicator
                showLoading();

                // Show upload status message
                const statusDiv = document.createElement('div');
                statusDiv.id = 'upload-status';
                statusDiv.style.cssText = 'margin-top:10px; font-size:0.9em; color:#007bff;';
                statusDiv.textContent = 'Uploading to Cloudinary... Please wait.';

                const previewContainer = document.getElementById('product-image-preview').parentNode;
                if (document.getElementById('upload-status')) {
                    document.getElementById('upload-status').remove();
                }
                previewContainer.appendChild(statusDiv);

                try {
                    // Upload the image to Cloudinary
                    const imageUrl = await uploadToCloudinary(file);

                    // Update status
                    if (document.getElementById('upload-status')) {
                        document.getElementById('upload-status').textContent = 'Upload complete!';
                        document.getElementById('upload-status').style.color = '#28a745';
                    }

                    // Set the image URL to the hidden input
                    document.getElementById('product-image').value = imageUrl;

                    // Show preview
                    document.getElementById('product-image-preview').src = imageUrl;
                    document.getElementById('product-image-preview').style.display = '';

                    // Check if it's a Cloudinary URL
                    if (imageUrl.includes('cloudinary.com')) {
                        console.log('Successfully uploaded to Cloudinary:', imageUrl);

                        // Add Cloudinary indicator next to preview
                        const cloudinaryIndicator = document.createElement('span');
                        cloudinaryIndicator.textContent = ' (Cloudinary)';
                        cloudinaryIndicator.style.fontSize = '0.9em';
                        cloudinaryIndicator.style.color = '#28a745'; // Green for Cloudinary
                        cloudinaryIndicator.style.fontWeight = 'bold';

                        const previewImg = document.getElementById('product-image-preview');
                        if (previewImg.nextSibling && previewImg.nextSibling.tagName === 'SPAN') {
                            previewImg.parentNode.removeChild(previewImg.nextSibling);
                        }
                        previewImg.parentNode.insertBefore(cloudinaryIndicator, previewImg.nextSibling);
                    } else {
                        // It's a base64 string (fallback)
                        console.log('Using base64 image (Cloudinary upload failed)');

                        // Add fallback indicator next to preview
                        const fallbackIndicator = document.createElement('span');
                        fallbackIndicator.textContent = ' (Local Storage)';
                        fallbackIndicator.style.fontSize = '0.9em';
                        fallbackIndicator.style.color = '#ffc107'; // Yellow for fallback
                        fallbackIndicator.style.fontWeight = 'bold';

                        const previewImg = document.getElementById('product-image-preview');
                        if (previewImg.nextSibling && previewImg.nextSibling.tagName === 'SPAN') {
                            previewImg.parentNode.removeChild(previewImg.nextSibling);
                        }
                        previewImg.parentNode.insertBefore(fallbackIndicator, previewImg.nextSibling);
                    }

                } catch (error) {
                    console.error('Image upload failed:', error);

                    // Update status
                    if (document.getElementById('upload-status')) {
                        document.getElementById('upload-status').textContent = 'Upload failed: ' + error.message;
                        document.getElementById('upload-status').style.color = '#dc3545';
                    }

                    alert('Failed to upload image. Please try again with a different image.');
                    this.value = ''; // Clear the file input
                } finally {
                    hideLoading();

                    // Remove status after 5 seconds
                    setTimeout(() => {
                        if (document.getElementById('upload-status')) {
                            document.getElementById('upload-status').remove();
                        }
                    }, 5000);
                }
            }
        });

        // Function to upload image to Cloudinary using unsigned upload preset
        async function uploadToCloudinary(file, folderName = 'product_images') {
            try {
                // Log file details
                console.log('Uploading image to Cloudinary:', file.name, 'Size:', Math.round(file.size/1024) + 'KB');

                // Create a FormData object to send the file
                const formData = new FormData();
                formData.append('file', file);

                // Use the unsigned upload preset you created in Cloudinary dashboard
                formData.append('upload_preset', 'tridex_products'); // Exact match with the preset name in Cloudinary dashboard

                // Note: The upload preset name is case-sensitive
                // If 'tridex_products' doesn't work, try 'Tridex_products' or check the exact name in your Cloudinary dashboard

                // Use a specific folder to make it easier to find uploads (this is optional if you set folder in preset)
                formData.append('folder', folderName);

                // Add a unique public_id to avoid conflicts
                const uniqueId = 'product_' + Date.now();
                formData.append('public_id', uniqueId);

                // Show upload progress in console
                console.log('Starting Cloudinary upload...');

                // Create a status notification
                const statusNotification = document.createElement('div');
                statusNotification.id = 'upload-status-notification';
                statusNotification.style.cssText = 'position:fixed; bottom:20px; left:20px; background:#007bff; color:#fff; padding:15px; border-radius:5px; box-shadow:0 2px 10px rgba(0,0,0,0.2); z-index:1000; max-width:400px;';
                statusNotification.innerHTML = `
                    <strong>Uploading to Cloudinary...</strong><br>
                    Please wait while your image is being uploaded.
                `;
                document.body.appendChild(statusNotification);

                try {
                    // Upload to Cloudinary with longer timeout
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout

                    // Get Cloudinary configuration from server environment
                    const cloudinaryConfig = await getCloudinaryConfig();

                    // Check if we have a valid cloud name
                    if (!cloudinaryConfig.cloudName || cloudinaryConfig.cloudName === 'your_cloud_name') {
                        console.error('Invalid Cloudinary cloud name');

                        // Remove the status notification
                        if (document.getElementById('upload-status-notification')) {
                            document.getElementById('upload-status-notification').remove();
                        }

                        // Fall back to base64
                        console.log('Falling back to base64 encoding due to invalid cloud name...');
                        return await fallbackToBase64(file);
                    }

                    // Add API key to the form data for authentication if available
                    if (cloudinaryConfig.apiKey && cloudinaryConfig.apiKey !== 'missing_api_key') {
                        formData.append('api_key', cloudinaryConfig.apiKey);
                        console.log('Using API key from server for authentication');
                    } else {
                        console.log('No API key available, attempting unsigned upload');

                        // Show a warning about missing API key
                        const warningDiv = document.createElement('div');
                        warningDiv.style.cssText = 'position:fixed; top:20px; left:20px; background:#fff3cd; color:#856404; padding:15px; border-radius:5px; box-shadow:0 2px 10px rgba(0,0,0,0.2); z-index:1000; max-width:400px;';
                        warningDiv.innerHTML = `
                            <h3 style="margin-top:0;">Cloudinary API Key Missing</h3>
                            <p>Attempting unsigned upload, but this may fail.</p>
                            <p>Check your server's .env file and make sure CLOUDINARY_API_KEY is set correctly.</p>
                            <button onclick="this.parentNode.remove()" style="padding:5px 10px; background:#856404; color:white; border:none; border-radius:3px; cursor:pointer;">Close</button>
                        `;
                        document.body.appendChild(warningDiv);

                        // Set a timeout to remove the warning after 10 seconds
                        setTimeout(() => {
                            if (document.body.contains(warningDiv)) {
                                document.body.removeChild(warningDiv);
                            }
                        }, 10000);
                    }

                    // Try to upload to Cloudinary
                    console.log(`Uploading to Cloudinary cloud: ${cloudinaryConfig.cloudName}`);
                    const response = await fetch(`https://api.cloudinary.com/v1_1/${cloudinaryConfig.cloudName}/image/upload`, {
                        method: 'POST',
                        body: formData,
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId); // Clear the timeout

                    // Remove the status notification
                    if (document.getElementById('upload-status-notification')) {
                        document.getElementById('upload-status-notification').remove();
                    }

                    // Check for errors
                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('Cloudinary error response:', errorText);

                        // Show error details
                        const errorDetails = document.createElement('div');
                        errorDetails.style.cssText = 'position:fixed; bottom:20px; right:20px; background:#f8d7da; color:#721c24; padding:15px; border-radius:5px; box-shadow:0 2px 10px rgba(0,0,0,0.2); z-index:1000; max-width:400px;';
                        errorDetails.innerHTML = `
                            <h3 style="margin-top:0;">Cloudinary Upload Failed</h3>
                            <p>Error: ${errorText}</p>
                            <p>Falling back to base64 encoding...</p>
                            <button onclick="this.parentNode.remove()" style="padding:5px 10px; background:#721c24; color:white; border:none; border-radius:3px; cursor:pointer;">Close</button>
                        `;
                        document.body.appendChild(errorDetails);

                        // Set a timeout to remove the error after 10 seconds
                        setTimeout(() => {
                            if (document.body.contains(errorDetails)) {
                                document.body.removeChild(errorDetails);
                            }
                        }, 10000);

                        // Fall back to base64 if Cloudinary upload fails
                        console.log('Falling back to base64 encoding...');
                        return await fallbackToBase64(file);
                    }

                    // Parse the response
                    const data = await response.json();
                    console.log('Cloudinary upload successful!', data);

                    // Log detailed information about the upload
                    console.log('Cloudinary upload details:');
                    console.log('- Public ID:', data.public_id);
                    console.log('- Format:', data.format);
                    console.log('- URL:', data.url);
                    console.log('- Secure URL:', data.secure_url);
                    console.log('- Original Filename:', data.original_filename);

                    // Create a success notification
                    const notification = document.createElement('div');
                    notification.style.cssText = 'position:fixed; bottom:20px; left:20px; background:#28a745; color:#fff; padding:15px; border-radius:5px; box-shadow:0 2px 10px rgba(0,0,0,0.2); z-index:1000; max-width:400px;';
                    notification.innerHTML = `
                        <strong>Cloudinary Upload Success!</strong><br>
                        Image uploaded to Cloudinary.<br>
                        <small>Check the "product_images" folder in your Media Library</small>
                    `;
                    document.body.appendChild(notification);

                    // Remove notification after 5 seconds
                    setTimeout(() => {
                        notification.style.opacity = '0';
                        notification.style.transition = 'opacity 0.5s ease';
                        setTimeout(() => notification.remove(), 500);
                    }, 5000);

                    // Return the secure URL of the uploaded image
                    return data.secure_url;
                } catch (fetchError) {
                    console.error('Error during Cloudinary upload:', fetchError);

                    // Remove the status notification
                    if (document.getElementById('upload-status-notification')) {
                        document.getElementById('upload-status-notification').remove();
                    }

                    // Fall back to base64 if Cloudinary upload fails
                    console.log('Falling back to base64 encoding...');
                    return await fallbackToBase64(file);
                }
            } catch (error) {
                console.error('Error in uploadToCloudinary:', error);

                // Fall back to base64 if anything fails
                return await fallbackToBase64(file);
            }
        }

        // Helper function for base64 fallback
        async function fallbackToBase64(file) {
            try {
                // First, let's optimize the image to reduce size
                let processedFile = file;

                // If the file is large, compress it
                if (file.size > 1024 * 1024) { // If larger than 1MB
                    try {
                        // Compress the image
                        processedFile = await compressImage(file, 1200, 0.9);
                        console.log('Image compressed to size:', Math.round(processedFile.size/1024) + 'KB');
                    } catch (compressionError) {
                        console.warn('Image compression failed, using original file:', compressionError);
                        processedFile = file;
                    }
                }

                // Convert to base64
                const base64String = await fileToBase64(processedFile);
                console.log('Image converted to base64, size:', Math.round(base64String.length/1024) + 'KB');

                // Create a notification about the fallback
                const notification = document.createElement('div');
                notification.style.cssText = 'position:fixed; bottom:20px; left:20px; background:#ffc107; color:#000; padding:15px; border-radius:5px; box-shadow:0 2px 10px rgba(0,0,0,0.2); z-index:1000; max-width:400px;';
                notification.innerHTML = `
                    <strong>Cloudinary Upload Failed</strong><br>
                    Falling back to base64 storage in database.<br>
                    <small>Check console for details.</small>
                `;
                document.body.appendChild(notification);

                // Remove notification after 5 seconds
                setTimeout(() => {
                    notification.style.opacity = '0';
                    notification.style.transition = 'opacity 0.5s ease';
                    setTimeout(() => notification.remove(), 500);
                }, 5000);

                return base64String;
            } catch (error) {
                console.error('Error in fallbackToBase64:', error);
                throw error;
            }
        }

        // Helper function to load an image and get its dimensions
        function loadImage(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = function(event) {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onload = function() {
                        resolve(img);
                    };
                    img.onerror = function(error) {
                        reject(error);
                    };
                };
                reader.onerror = function(error) {
                    reject(error);
                };
            });
        }

        // Helper function to compress and resize an image with better quality preservation
        function compressImage(file, maxDimension, quality) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = function(event) {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onload = function() {
                        // Calculate new dimensions while preserving aspect ratio
                        let width = img.width;
                        let height = img.height;

                        // Determine which dimension to constrain
                        if (width > height) {
                            // Landscape image
                            if (width > maxDimension) {
                                height = Math.round(height * maxDimension / width);
                                width = maxDimension;
                            }
                        } else {
                            // Portrait or square image
                            if (height > maxDimension) {
                                width = Math.round(width * maxDimension / height);
                                height = maxDimension;
                            }
                        }

                        console.log('Resizing to:', width + 'x' + height, 'with quality:', quality);

                        // Create canvas for resizing
                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;

                        // Draw and compress image on canvas with better quality
                        const ctx = canvas.getContext('2d');
                        ctx.imageSmoothingEnabled = true;
                        ctx.imageSmoothingQuality = 'high';
                        ctx.drawImage(img, 0, 0, width, height);

                        // Convert to blob with compression
                        canvas.toBlob(function(blob) {
                            resolve(blob);
                        }, 'image/jpeg', quality); // Always use JPEG for better compression
                    };
                    img.onerror = function(error) {
                        reject(error);
                    };
                };
                reader.onerror = function(error) {
                    reject(error);
                };
            });
        }

        // Helper function to convert a file to base64
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(error);
            });
        }

        // Add/Edit Product (DB version)
        document.getElementById('product-form').onsubmit = async function(e) {
            e.preventDefault();

            // Show loading indicator
            showLoading();

            const id = document.getElementById('product-id').value;
            const name = document.getElementById('product-name').value.trim();
            let image = document.getElementById('product-image').value.trim();
            const desc = document.getElementById('product-desc').value.trim();
            const price = document.getElementById('product-price').value.trim();

            // Validate inputs
            if (!name) {
                alert('Product name is required');
                hideLoading();
                return;
            }

            if (!price || isNaN(price) || price <= 0) {
                alert('Please enter a valid price');
                hideLoading();
                return;
            }

            // Log image information
            if (image) {
                if (image.includes('cloudinary.com')) {
                    console.log('Submitting product with Cloudinary URL:', image);
                } else {
                    // It's a base64 string
                    const sizeKB = Math.round(image.length/1024);
                    console.log('Submitting product with base64 image, size:', sizeKB + 'KB');
                }
            }

            try {
                // Prepare the product data
                const productData = { name, desc, price };

                // Only include image if it's not empty
                if (image) {
                    productData.image = image;
                }

                if (id) {
                    // Update
                    const response = await fetch(`https://tridex1.onrender.com/products/${id}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(productData)
                    });

                    if (!response.ok) {
                        if (response.status === 413) {
                            throw new Error('The image is too large for the server to process. Please use a smaller image.');
                        } else {
                            throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                        }
                    }

                    // Log the response for debugging
                    const responseData = await response.json();
                    console.log('Product update response:', responseData);

                    alert('Product updated successfully!');
                } else {
                    // Add
                    const response = await fetch('https://tridex1.onrender.com/products', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(productData)
                    });

                    if (!response.ok) {
                        if (response.status === 413) {
                            throw new Error('The image is too large for the server to process. Please use a smaller image.');
                        } else {
                            throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                        }
                    }

                    // Log the response for debugging
                    const responseData = await response.json();
                    console.log('Product add response:', responseData);

                    alert('Product added successfully!');
                }

                // Reset form
                this.reset();
                document.getElementById('product-save-btn').textContent = 'Add Product';
                document.getElementById('product-cancel-btn').style.display = 'none';
                document.getElementById('product-image-preview').style.display = 'none';
                document.getElementById('product-image').value = '';

                // Refresh product list
                fetchProducts();
            } catch (e) {
                console.error('Product operation failed:', e);
                alert(`Failed to ${id ? 'update' : 'add'} product: ${e.message}`);
            } finally {
                hideLoading();
            }
        };
        // Cancel edit
        document.getElementById('product-cancel-btn').onclick = function() {
            document.getElementById('product-form').reset();
            document.getElementById('product-save-btn').textContent = 'Add Product';
            this.style.display = 'none';
            document.getElementById('product-image-preview').style.display = 'none';
            document.getElementById('product-image').value = '';
        };

        // --- Announcement Management (DB version) ---
        async function fetchAnnouncements() {
            try {
                const res = await fetch('https://tridex1.onrender.com/announcements');
                announcements = await res.json();
                renderAdminMessages();
            } catch (e) {
                announcements = [];
                renderAdminMessages();
                alert('Failed to load announcements from database.');
            }
        }
        document.getElementById('admin-mail-form').onsubmit = async function(e) {
            e.preventDefault();

            // Show loading indicator
            showLoading();

            const title = document.getElementById('mail-title').value.trim();
            const message = document.getElementById('mail-body').value.trim();

            // Validate inputs
            if (!title) {
                alert('Announcement title is required');
                hideLoading();
                return;
            }

            if (!message) {
                alert('Announcement message is required');
                hideLoading();
                return;
            }

            try {
                const response = await fetch('https://tridex1.onrender.com/announcements', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title, message })
                });

                if (!response.ok) {
                    throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                }

                alert('Announcement sent successfully!');
                document.getElementById('admin-mail-modal').style.display = 'none';
                this.reset();
                fetchAnnouncements();
            } catch (e) {
                console.error('Failed to send announcement:', e);
                alert(`Failed to send announcement: ${e.message}`);
            } finally {
                hideLoading();
            }
        };
        function renderAdminMessages() {
            const messagesDiv = document.getElementById('admin-mailbox-messages');
            if (!announcements || announcements.length === 0) {
                messagesDiv.innerHTML = '<p style="color:#888;">No messages.</p>';
            } else {
                messagesDiv.innerHTML = announcements.map((msg, idx) =>
                    `<div style="border-bottom:1px solid #eee; padding:8px 0;">
                        <strong>${msg.title || 'Announcement'}</strong>
                        <div style="font-size:0.97em; margin-top:4px;">${msg.message}</div>
                        <div style="font-size:0.85em; color:#888; margin-top:2px;">${new Date(msg.createdAt).toLocaleString() || ''}</div>
                        <button class="delete-msg-btn" data-id="${msg._id}" style="margin-top:6px; padding:4px 12px; background:#dc3545; color:#fff; border:none; border-radius:4px; font-size:0.95em; cursor:pointer;">Delete</button>
                    </div>`
                ).join('');
                // Add delete handlers
                messagesDiv.querySelectorAll('.delete-msg-btn').forEach(btn => {
                    btn.onclick = async function() {
                        const id = this.getAttribute('data-id');
                        if (confirm('Delete this message?')) {
                            // Show loading indicator
                            showLoading();

                            try {
                                const response = await fetch(`https://tridex1.onrender.com/announcements/${id}`, { method: 'DELETE' });

                                if (!response.ok) {
                                    throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                                }

                                fetchAnnouncements();
                            } catch (e) {
                                console.error('Failed to delete announcement:', e);
                                alert(`Failed to delete announcement: ${e.message}`);
                            } finally {
                                hideLoading();
                            }
                        }
                    };
                });
            }
        }
        // Show mailbox modal and fetch announcements
        document.getElementById('show-mail-btn').onclick = function() {
            document.getElementById('admin-mail-modal').style.display = 'flex';
            fetchAnnouncements();
        };
        document.getElementById('close-admin-mail').onclick = function() {
            document.getElementById('admin-mail-modal').style.display = 'none';
        };

        // --- Navigation between sections ---
        document.getElementById('show-users-btn').onclick = function() {
            document.getElementById('user-section').style.display = '';
            document.getElementById('product-section').style.display = 'none';
            document.getElementById('category-section').style.display = 'none';
            document.querySelectorAll('.admin-nav-btn').forEach(btn => btn.classList.remove('active'));
            this.classList.add('active');
        };
        document.getElementById('show-products-btn').onclick = function() {
            document.getElementById('user-section').style.display = 'none';
            document.getElementById('product-section').style.display = '';
            document.getElementById('category-section').style.display = 'none';
            document.querySelectorAll('.admin-nav-btn').forEach(btn => btn.classList.remove('active'));
            this.classList.add('active');
        };
        document.getElementById('show-categories-btn').onclick = function() {
            document.getElementById('user-section').style.display = 'none';
            document.getElementById('product-section').style.display = 'none';
            document.getElementById('category-section').style.display = '';
            document.querySelectorAll('.admin-nav-btn').forEach(btn => btn.classList.remove('active'));
            this.classList.add('active');
        };

        function showLoading() {
            document.getElementById('loading-overlay').style.display = 'flex';
        }
        function hideLoading() {
            document.getElementById('loading-overlay').style.display = 'none';
        }
        window.addEventListener('load', function() {
            hideLoading();
        });
        window.addEventListener('beforeunload', function() {
            showLoading();
        });

        // Debug ban system button
        document.getElementById('debug-ban-system').addEventListener('click', function() {
            if (window.banSystem) {
                const bannedUsers = window.banSystem.debugBanSystem();
                document.getElementById('debug-output').textContent =
                    bannedUsers.length > 0 ?
                    `Banned users: ${bannedUsers.join(', ')}` :
                    'No banned users found';
            } else {
                document.getElementById('debug-output').textContent = 'Ban system not available';
            }
        });

        // Function to check Cloudinary connection and test upload preset
        async function checkCloudinaryConnection() {
            try {
                // Update status
                const statusSpan = document.getElementById('cloudinary-status');
                if (statusSpan) {
                    statusSpan.textContent = 'Testing Cloudinary connection...';
                    statusSpan.style.color = '#007bff';
                }

                // Create a small test image (1x1 pixel transparent PNG)
                const base64Image = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';

                // Convert base64 to blob
                const response = await fetch(base64Image);
                const blob = await response.blob();
                const file = new File([blob], 'cloudinary_test.png', { type: 'image/png' });

                // Create a FormData object to send the file
                const formData = new FormData();
                formData.append('file', file);

                // Try both uppercase and lowercase preset names
                // The preset name is case-sensitive and must match exactly what's in your Cloudinary dashboard
                const presetName = 'tridex_products'; // Try lowercase first
                formData.append('upload_preset', presetName);

                formData.append('folder', 'test_uploads');
                formData.append('public_id', 'connection_test_' + Date.now());

                console.log(`Testing Cloudinary connection with upload preset "${presetName}"...`);

                // Get Cloudinary configuration from server environment
                const cloudinaryConfig = await getCloudinaryConfig();

                // Check if we have a valid cloud name
                if (!cloudinaryConfig.cloudName || cloudinaryConfig.cloudName === 'your_cloud_name') {
                    throw new Error('Invalid Cloudinary cloud name. Please check your server configuration.');
                }

                // Add API key to the form data for authentication if available
                if (cloudinaryConfig.apiKey && cloudinaryConfig.apiKey !== 'missing_api_key') {
                    formData.append('api_key', cloudinaryConfig.apiKey);
                    console.log('Using API key from server for authentication');
                } else {
                    console.log('No API key available, attempting unsigned upload');

                    // Show a warning about missing API key
                    const warningDiv = document.createElement('div');
                    warningDiv.style.cssText = 'position:fixed; top:20px; left:20px; background:#fff3cd; color:#856404; padding:15px; border-radius:5px; box-shadow:0 2px 10px rgba(0,0,0,0.2); z-index:1000; max-width:400px;';
                    warningDiv.innerHTML = `
                        <h3 style="margin-top:0;">Cloudinary API Key Missing</h3>
                        <p>Attempting unsigned upload, but this may fail.</p>
                        <p>Check your server's .env file and make sure CLOUDINARY_API_KEY is set correctly.</p>
                        <button onclick="this.parentNode.remove()" style="padding:5px 10px; background:#856404; color:white; border:none; border-radius:3px; cursor:pointer;">Close</button>
                    `;
                    document.body.appendChild(warningDiv);

                    // Set a timeout to remove the warning after 10 seconds
                    setTimeout(() => {
                        if (document.body.contains(warningDiv)) {
                            document.body.removeChild(warningDiv);
                        }
                    }, 10000);
                }

                // Try the upload
                console.log(`Uploading to Cloudinary cloud: ${cloudinaryConfig.cloudName}`);
                const uploadResponse = await fetch(`https://api.cloudinary.com/v1_1/${cloudinaryConfig.cloudName}/image/upload`, {
                    method: 'POST',
                    body: formData
                });

                // Check if the upload was successful
                if (uploadResponse.ok) {
                    const uploadResult = await uploadResponse.json();
                    console.log('Cloudinary test upload successful!', uploadResult);

                    // Update status
                    if (statusSpan) {
                        statusSpan.textContent = 'Connected';
                        statusSpan.style.color = '#28a745';
                    }

                    // Show success message
                    const successReport = document.createElement('div');
                    successReport.style.cssText = 'position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:white; padding:20px; border-radius:5px; box-shadow:0 2px 10px rgba(0,0,0,0.2); z-index:1000; max-width:600px;';
                    successReport.innerHTML = `
                        <h3 style="margin-top:0; color:#28a745;">✅ Cloudinary Connection Successful</h3>
                        <p>Successfully connected to Cloudinary and uploaded a test image.</p>
                        <p><strong>Cloud Name:</strong> ${cloudinaryConfig.cloudName}</p>
                        <p><strong>Upload Preset:</strong> ${presetName}</p>
                        <p><strong>API Key Available:</strong> ${cloudinaryConfig.apiKey ? 'Yes' : 'No'}</p>
                        <p><strong>Test Image URL:</strong> <a href="${uploadResult.secure_url}" target="_blank">${uploadResult.secure_url}</a></p>
                        <img src="${uploadResult.secure_url}" style="max-width:100px; margin:10px 0; border:1px solid #ddd;">
                        <p>Your Cloudinary configuration is working correctly.</p>
                        <button class="btn btn-primary" onclick="this.parentNode.remove()">Close</button>
                    `;
                    document.body.appendChild(successReport);

                    return true;
                } else {
                    const errorText = await uploadResponse.text();
                    console.error('Cloudinary test upload failed:', errorText);

                    // Try with uppercase preset name if lowercase failed
                    if (presetName === 'tridex_products') {
                        console.log('Trying with uppercase preset name "Tridex_products"...');

                        // Create a new FormData object
                        const formData2 = new FormData();
                        formData2.append('file', file);
                        formData2.append('upload_preset', 'Tridex_products');
                        formData2.append('folder', 'test_uploads');
                        formData2.append('public_id', 'connection_test_uppercase_' + Date.now());

                        // Add API key if available
                        if (cloudinaryConfig.apiKey && cloudinaryConfig.apiKey !== 'missing_api_key') {
                            formData2.append('api_key', cloudinaryConfig.apiKey);
                        }

                        try {
                            // Try the upload with uppercase preset
                            const uploadResponse2 = await fetch(`https://api.cloudinary.com/v1_1/${cloudinaryConfig.cloudName}/image/upload`, {
                                method: 'POST',
                                body: formData2
                            });

                            if (uploadResponse2.ok) {
                                const uploadResult2 = await uploadResponse2.json();
                                console.log('Cloudinary test upload successful with uppercase preset!', uploadResult2);

                                // Update status
                                if (statusSpan) {
                                    statusSpan.textContent = 'Connected';
                                    statusSpan.style.color = '#28a745';
                                }

                                // Show success message
                                const successReport = document.createElement('div');
                                successReport.style.cssText = 'position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:white; padding:20px; border-radius:5px; box-shadow:0 2px 10px rgba(0,0,0,0.2); z-index:1000; max-width:600px;';
                                successReport.innerHTML = `
                                    <h3 style="margin-top:0; color:#28a745;">✅ Cloudinary Connection Successful</h3>
                                    <p>Successfully connected to Cloudinary and uploaded a test image.</p>
                                    <p><strong>Cloud Name:</strong> ${cloudinaryConfig.cloudName}</p>
                                    <p><strong>Upload Preset:</strong> Tridex_products (uppercase worked)</p>
                                    <p><strong>API Key Available:</strong> ${cloudinaryConfig.apiKey ? 'Yes' : 'No'}</p>
                                    <p><strong>Test Image URL:</strong> <a href="${uploadResult2.secure_url}" target="_blank">${uploadResult2.secure_url}</a></p>
                                    <img src="${uploadResult2.secure_url}" style="max-width:100px; margin:10px 0; border:1px solid #ddd;">
                                    <p>Your Cloudinary configuration is working correctly, but you should update your code to use "Tridex_products" (uppercase T) as the preset name.</p>
                                    <button class="btn btn-primary" onclick="this.parentNode.remove()">Close</button>
                                `;
                                document.body.appendChild(successReport);

                                return true;
                            } else {
                                // Both lowercase and uppercase failed
                                const errorText2 = await uploadResponse2.text();
                                console.error('Cloudinary test upload failed with uppercase preset:', errorText2);

                                // Continue to show error message for both attempts
                                showErrorMessage(cloudinaryConfig, errorText, errorText2);
                                return false;
                            }
                        } catch (error2) {
                            console.error('Error testing Cloudinary connection with uppercase preset:', error2);
                            showErrorMessage(cloudinaryConfig, errorText, error2.message);
                            return false;
                        }
                    } else {
                        // Show error message for the first attempt
                        showErrorMessage(cloudinaryConfig, errorText);
                        return false;
                    }
                }
            } catch (error) {
                console.error('Error testing Cloudinary connection:', error);

                // Update status
                const statusSpan = document.getElementById('cloudinary-status');
                if (statusSpan) {
                    statusSpan.textContent = 'Connection error';
                    statusSpan.style.color = '#dc3545';
                }

                // Show error message
                const errorReport = document.createElement('div');
                errorReport.style.cssText = 'position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:white; padding:20px; border-radius:5px; box-shadow:0 2px 10px rgba(0,0,0,0.2); z-index:1000; max-width:600px;';
                errorReport.innerHTML = `
                    <h3 style="margin-top:0; color:#dc3545;">❌ Cloudinary Connection Error</h3>
                    <p>An error occurred while testing the Cloudinary connection.</p>
                    <p><strong>Error:</strong> ${error.message}</p>
                    <p><strong>Possible issues:</strong></p>
                    <ul>
                        <li>Server is not providing Cloudinary configuration</li>
                        <li>Network connectivity issues</li>
                        <li>Invalid Cloudinary credentials</li>
                    </ul>

                    <p>For now, the system will fall back to base64 storage until the connection issues are resolved.</p>

                    <button class="btn btn-primary" onclick="this.parentNode.remove()" style="padding:8px 16px; background:#007bff; color:white; border:none; border-radius:4px; cursor:pointer; margin-top:10px;">Close</button>
                `;
                document.body.appendChild(errorReport);

                return false;
            }
        }

        // Helper function to show error message for Cloudinary connection
        function showErrorMessage(cloudinaryConfig, errorText, errorText2 = null) {
            // Update status
            const statusSpan = document.getElementById('cloudinary-status');
            if (statusSpan) {
                statusSpan.textContent = 'Connection error';
                statusSpan.style.color = '#dc3545';
            }

            // Show error message
            const errorReport = document.createElement('div');
            errorReport.style.cssText = 'position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:white; padding:20px; border-radius:5px; box-shadow:0 2px 10px rgba(0,0,0,0.2); z-index:1000; max-width:600px; overflow-y:auto; max-height:80vh;';

            let errorContent = `
                <h3 style="margin-top:0; color:#dc3545;">❌ Cloudinary Connection Failed</h3>
                <p>Failed to connect to Cloudinary or upload a test image.</p>
                <p><strong>Cloud Name:</strong> ${cloudinaryConfig.cloudName}</p>
                <p><strong>API Key Available:</strong> ${cloudinaryConfig.apiKey ? 'Yes' : 'No'}</p>
                <p><strong>Error with lowercase preset (tridex_products):</strong> ${errorText}</p>
            `;

            if (errorText2) {
                errorContent += `<p><strong>Error with uppercase preset (Tridex_products):</strong> ${errorText2}</p>`;
            }

            errorContent += `
                <p><strong>Possible issues:</strong></p>
                <ul>
                    <li>API key is missing or invalid in your .env file</li>
                    <li>Upload preset doesn't exist in your Cloudinary account</li>
                    <li>Upload preset is not set to "unsigned"</li>
                    <li>The preset name is case-sensitive and must match exactly</li>
                    <li>Network connectivity issues</li>
                </ul>

                <p><strong>How to fix:</strong></p>
                <ol>
                    <li>Check your server's .env file and make sure CLOUDINARY_API_KEY is set correctly</li>
                    <li>Go to your Cloudinary dashboard > Settings > Upload > Upload presets</li>
                    <li>Create a new preset named "tridex_products" (or check if it exists)</li>
                    <li>Make sure the preset is set to "unsigned"</li>
                    <li>Restart your server after making changes to the .env file</li>
                </ol>

                <p>For now, the system will fall back to base64 storage until the connection issues are resolved.</p>

                <button class="btn btn-primary" onclick="this.parentNode.remove()" style="padding:8px 16px; background:#007bff; color:white; border:none; border-radius:4px; cursor:pointer; margin-top:10px;">Close</button>
            `;

            errorReport.innerHTML = errorContent;
            document.body.appendChild(errorReport);
        }

        // Function to verify if product images are stored in Cloudinary
        async function verifyProductImages() {
            try {
                // Show loading indicator
                showLoading();

                // Fetch all products
                const response = await fetch('https://tridex1.onrender.com/products');
                if (!response.ok) {
                    throw new Error(`Failed to fetch products: ${response.status} ${response.statusText}`);
                }

                const products = await response.json();
                console.log(`Verifying ${products.length} products for Cloudinary images...`);

                // Count Cloudinary vs base64 images
                let cloudinaryCount = 0;
                let base64Count = 0;
                let noImageCount = 0;

                // Check each product
                products.forEach(product => {
                    if (!product.image) {
                        noImageCount++;
                    } else if (product.image.includes('cloudinary.com')) {
                        cloudinaryCount++;
                    } else if (product.image.startsWith('data:image')) {
                        base64Count++;
                    } else {
                        console.log('Unknown image format for product:', product.name);
                    }
                });

                // Create a report
                const report = document.createElement('div');
                report.style.cssText = 'position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:#fff; color:#333; padding:20px; border-radius:5px; box-shadow:0 5px 15px rgba(0,0,0,0.3); z-index:1001; max-width:500px;';
                report.innerHTML = `
                    <h4>Product Image Report</h4>
                    <p>Total Products: ${products.length}</p>
                    <p style="color:#28a745;"><strong>Cloudinary Images:</strong> ${cloudinaryCount}</p>
                    <p style="color:#ffc107;"><strong>Base64 Images:</strong> ${base64Count}</p>
                    <p><strong>No Images:</strong> ${noImageCount}</p>
                    <p>To see Cloudinary images in your Media Library, make sure you're logged in to the correct account.</p>
                    <button class="btn btn-primary" onclick="this.parentNode.remove()">Close</button>
                `;
                document.body.appendChild(report);

                console.log('Image verification complete:');
                console.log('- Cloudinary images:', cloudinaryCount);
                console.log('- Base64 images:', base64Count);
                console.log('- No images:', noImageCount);

            } catch (error) {
                console.error('Error verifying product images:', error);
                alert('Failed to verify product images: ' + error.message);
            } finally {
                hideLoading();
            }
        }

        // Add event listeners for Cloudinary verification buttons
        document.getElementById('verify-cloudinary-btn').addEventListener('click', function() {
            checkCloudinaryConnection();
        });

        document.getElementById('verify-product-images-btn').addEventListener('click', function() {
            verifyProductImages();
        });

        // --- Category Management ---
        let categories = [];

        async function fetchCategories() {
            try {
                const res = await fetch('https://tridex1.onrender.com/categories');
                categories = await res.json();
                renderCategories();
                populateCategoryDropdown();
            } catch (e) {
                console.error('Failed to load categories:', e);
                categories = [];
                renderCategories();
                alert('Failed to load categories from database.');
            }
        }

        function renderCategories() {
            const tbody = document.querySelector('#category-list tbody');
            tbody.innerHTML = '';

            if (!categories || categories.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" style="text-align:center; padding:20px; color:#888;">No categories found. Add your first category above.</td></tr>';
                return;
            }

            categories.forEach(category => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>
                        <img src="${category.icon || 'https://via.placeholder.com/50?text=No+Icon'}"
                             alt="${category.name}"
                             style="width:50px; height:50px; object-fit:contain; border-radius:50%; background:#f9f9f9;">
                    </td>
                    <td>${category.name}</td>
                    <td>${category.description || ''}</td>
                    <td><span class="product-count" data-id="${category._id}">Loading...</span></td>
                    <td>
                        <button class="edit-btn" data-id="${category._id}">Edit</button>
                        <button class="delete-btn" data-id="${category._id}">Delete</button>
                        <button class="view-products-btn" data-id="${category._id}">View Products</button>
                    </td>
                `;

                // Get product count for this category
                getProductCountForCategory(category._id);

                // Add event handlers
                tr.querySelector('.edit-btn').onclick = function() {
                    setCategoryForm(category);
                };

                tr.querySelector('.delete-btn').onclick = async function() {
                    if (confirm('Delete this category? This will not delete the products in this category.')) {
                        try {
                            showLoading();
                            const response = await fetch(`https://tridex1.onrender.com/categories/${category._id}`, {
                                method: 'DELETE'
                            });

                            if (!response.ok) {
                                const errorData = await response.json();
                                throw new Error(errorData.message || 'Failed to delete category');
                            }

                            fetchCategories();
                        } catch (e) {
                            alert(e.message || 'Failed to delete category.');
                        } finally {
                            hideLoading();
                        }
                    }
                };

                tr.querySelector('.view-products-btn').onclick = function() {
                    window.open(`category.html?id=${category._id}`, '_blank');
                };

                tbody.appendChild(tr);
            });
        }

        async function getProductCountForCategory(categoryId) {
            try {
                const res = await fetch(`https://tridex1.onrender.com/categories/${categoryId}/products`);
                const products = await res.json();

                // Update the count in the table
                const countSpan = document.querySelector(`.product-count[data-id="${categoryId}"]`);
                if (countSpan) {
                    countSpan.textContent = products.length;
                }
            } catch (e) {
                console.error(`Failed to get product count for category ${categoryId}:`, e);
                const countSpan = document.querySelector(`.product-count[data-id="${categoryId}"]`);
                if (countSpan) {
                    countSpan.textContent = 'Error';
                }
            }
        }

        function setCategoryForm(category) {
            document.getElementById('category-id').value = category._id;
            document.getElementById('category-name').value = category.name;
            document.getElementById('category-icon').value = category.icon || '';
            document.getElementById('category-desc').value = category.description || '';
            document.getElementById('category-save-btn').textContent = 'Update Category';
            document.getElementById('category-cancel-btn').style.display = '';

            if (category.icon) {
                document.getElementById('category-icon-preview').src = category.icon;
                document.getElementById('category-icon-preview').style.display = '';
            } else {
                document.getElementById('category-icon-preview').style.display = 'none';
            }
        }

        // Handle category icon file upload
        document.getElementById('category-icon-file').onchange = async function(e) {
            const file = e.target.files[0];
            if (!file) return;

            try {
                showLoading();

                // Upload to Cloudinary
                const iconUrl = await uploadToCloudinary(file, 'category_icons');

                // Set the icon URL in the hidden input
                document.getElementById('category-icon').value = iconUrl;

                // Show preview
                document.getElementById('category-icon-preview').src = iconUrl;
                document.getElementById('category-icon-preview').style.display = '';
            } catch (error) {
                console.error('Error uploading category icon:', error);
                alert('Failed to upload icon: ' + error.message);
            } finally {
                hideLoading();
            }
        };

        // Add/Edit Category
        document.getElementById('category-form').onsubmit = async function(e) {
            e.preventDefault();

            showLoading();

            const id = document.getElementById('category-id').value;
            const name = document.getElementById('category-name').value.trim();
            const icon = document.getElementById('category-icon').value.trim();
            const description = document.getElementById('category-desc').value.trim();

            // Validate inputs
            if (!name) {
                alert('Category name is required');
                hideLoading();
                return;
            }

            try {
                const categoryData = { name, description };

                // Only include icon if it's not empty
                if (icon) {
                    categoryData.icon = icon;
                }

                if (id) {
                    // Update
                    const response = await fetch(`https://tridex1.onrender.com/categories/${id}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(categoryData)
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.message || `Server returned ${response.status}`);
                    }

                    alert('Category updated successfully!');
                } else {
                    // Add
                    const response = await fetch('https://tridex1.onrender.com/categories', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(categoryData)
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.message || `Server returned ${response.status}`);
                    }

                    alert('Category added successfully!');
                }

                // Reset form
                this.reset();
                document.getElementById('category-save-btn').textContent = 'Add Category';
                document.getElementById('category-cancel-btn').style.display = 'none';
                document.getElementById('category-icon-preview').style.display = 'none';
                document.getElementById('category-icon').value = '';

                // Refresh categories
                fetchCategories();
            } catch (e) {
                console.error('Category operation failed:', e);
                alert(`Failed to ${id ? 'update' : 'add'} category: ${e.message}`);
            } finally {
                hideLoading();
            }
        };

        // Cancel category edit
        document.getElementById('category-cancel-btn').onclick = function() {
            document.getElementById('category-form').reset();
            document.getElementById('category-save-btn').textContent = 'Add Category';
            this.style.display = 'none';
            document.getElementById('category-icon-preview').style.display = 'none';
            document.getElementById('category-icon').value = '';
        };

        // Populate category dropdown in product form
        function populateCategoryDropdown() {
            const select = document.getElementById('product-category');

            // Keep the first option (-- Select Category --)
            const firstOption = select.options[0];
            select.innerHTML = '';
            select.appendChild(firstOption);

            // Add categories
            categories.forEach(category => {
                const option = document.createElement('option');
                option.value = category._id;
                option.textContent = category.name;
                select.appendChild(option);
            });
        }

        // Update product form to include category
        const originalSetProductForm = window.setProductForm;
        window.setProductForm = function(product) {
            originalSetProductForm(product);

            // Set category if it exists
            if (product.category) {
                document.getElementById('product-category').value =
                    typeof product.category === 'object' ? product.category._id : product.category;
            } else {
                document.getElementById('product-category').value = '';
            }
        };

        // Update product rendering to include category
        const originalRenderProducts = window.renderProducts;
        window.renderProducts = function() {
            const tbody = document.querySelector('#product-list tbody');
            tbody.innerHTML = '';
            (products || []).forEach(product => {
                const tr = document.createElement('tr');

                // Get category name
                let categoryName = 'None';
                if (product.category) {
                    const categoryId = typeof product.category === 'object' ? product.category._id : product.category;
                    const category = categories.find(c => c._id === categoryId);
                    if (category) {
                        categoryName = category.name;
                    }
                }

                tr.innerHTML = `
                    <td><img src="${product.image || ''}" alt="${product.name}" style="cursor:pointer;" class="product-img" data-id="${product._id}"></td>
                    <td>${product.name}</td>
                    <td>${product.desc}</td>
                    <td>₹${product.price}</td>
                    <td>${categoryName}</td>
                    <td>
                        <button class="edit-btn" data-id="${product._id}">Edit</button>
                        <button class="delete-btn" data-id="${product._id}">Delete</button>
                    </td>
                `;
                tr.querySelector('.product-img').onclick = function() {
                    window.location.href = `product-details.html?id=${product._id}`;
                };
                tr.querySelector('.edit-btn').onclick = function() {
                    setProductForm(product);
                };
                tr.querySelector('.delete-btn').onclick = async function() {
                    if (confirm('Delete this product?')) {
                        try {
                            await fetch(`https://tridex1.onrender.com/products/${product._id}`, { method: 'DELETE' });
                            fetchProducts();
                        } catch (e) { alert('Failed to delete product.'); }
                    }
                };
                tbody.appendChild(tr);
            });
        };

        // Update product form submission to include category
        const originalProductFormSubmit = document.getElementById('product-form').onsubmit;
        document.getElementById('product-form').onsubmit = async function(e) {
            e.preventDefault();

            // Show loading indicator
            showLoading();

            const id = document.getElementById('product-id').value;
            const name = document.getElementById('product-name').value.trim();
            let image = document.getElementById('product-image').value.trim();
            const desc = document.getElementById('product-desc').value.trim();
            const price = document.getElementById('product-price').value.trim();
            const category = document.getElementById('product-category').value;

            // Validate inputs
            if (!name) {
                alert('Product name is required');
                hideLoading();
                return;
            }

            if (!price || isNaN(price) || price <= 0) {
                alert('Please enter a valid price');
                hideLoading();
                return;
            }

            try {
                // Prepare the product data
                const productData = { name, desc, price };

                // Only include image if it's not empty
                if (image) {
                    productData.image = image;
                }

                // Only include category if it's not empty
                if (category) {
                    productData.category = category;
                }

                if (id) {
                    // Update
                    const response = await fetch(`https://tridex1.onrender.com/products/${id}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(productData)
                    });

                    if (!response.ok) {
                        if (response.status === 413) {
                            throw new Error('The image is too large for the server to process. Please use a smaller image.');
                        } else {
                            throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                        }
                    }

                    alert('Product updated successfully!');
                } else {
                    // Add
                    const response = await fetch('https://tridex1.onrender.com/products', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(productData)
                    });

                    if (!response.ok) {
                        if (response.status === 413) {
                            throw new Error('The image is too large for the server to process. Please use a smaller image.');
                        } else {
                            throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                        }
                    }

                    alert('Product added successfully!');
                }

                // Reset form
                this.reset();
                document.getElementById('product-save-btn').textContent = 'Add Product';
                document.getElementById('product-cancel-btn').style.display = 'none';
                document.getElementById('product-image-preview').style.display = 'none';
                document.getElementById('product-image').value = '';

                // Refresh product list
                fetchProducts();
            } catch (e) {
                console.error('Product operation failed:', e);
                alert(`Failed to ${id ? 'update' : 'add'} product: ${e.message}`);
            } finally {
                hideLoading();
            }

            return false; // Prevent default form submission
        };

        // On load
        fetchUsers();
        fetchProducts();
        fetchCategories();
    </script>
</body>
</html>
